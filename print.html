<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>StarryOS-pulsar-development</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="iwantsay.html"><strong aria-hidden="true">1.</strong> 概述</a></li><li class="chapter-item "><a href="plan/plan.html"><strong aria-hidden="true">2.</strong> 开发计划</a></li><li class="chapter-item "><a href="develop_log/index.html"><strong aria-hidden="true">3.</strong> 项目周报</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="develop_log/第一周/log.html"><strong aria-hidden="true">3.1.</strong> 第一周</a></li></ol></li><li class="chapter-item "><a href="documents/docs.html"><strong aria-hidden="true">4.</strong> 项目文档</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="documents/rknn-manual.html"><strong aria-hidden="true">4.1.</strong> rknn手册</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="documents/rknn-hardware.html"><strong aria-hidden="true">4.1.1.</strong> rknn硬件手册</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="documents/rknn-feature.html"><strong aria-hidden="true">4.1.1.1.</strong> RKNN 硬件特性</a></li><li class="chapter-item "><a href="documents/register-map.html"><strong aria-hidden="true">4.1.1.2.</strong> 寄存器图</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="documents/registers/pc.html"><strong aria-hidden="true">4.1.1.2.1.</strong> PC</a></li><li class="chapter-item "><a href="documents/registers/cna.html"><strong aria-hidden="true">4.1.1.2.2.</strong> CNA</a></li><li class="chapter-item "><a href="documents/registers/core.html"><strong aria-hidden="true">4.1.1.2.3.</strong> CORE</a></li><li class="chapter-item "><a href="documents/registers/dpu.html"><strong aria-hidden="true">4.1.1.2.4.</strong> DPU</a></li><li class="chapter-item "><a href="documents/registers/dpu-rdma.html"><strong aria-hidden="true">4.1.1.2.5.</strong> DPU_RDMA</a></li><li class="chapter-item "><a href="documents/registers/ppu.html"><strong aria-hidden="true">4.1.1.2.6.</strong> PPU</a></li><li class="chapter-item "><a href="documents/registers/ppu-rdma.html"><strong aria-hidden="true">4.1.1.2.7.</strong> PPU_RDMA</a></li><li class="chapter-item "><a href="documents/registers/ddma-sdma.html"><strong aria-hidden="true">4.1.1.2.8.</strong> DDMA / SDMA</a></li><li class="chapter-item "><a href="documents/registers/global.html"><strong aria-hidden="true">4.1.1.2.9.</strong> GLOBAL</a></li></ol></li></ol></li><li class="chapter-item "><a href="documents/ioctl-protocol.html"><strong aria-hidden="true">4.1.2.</strong> IOCTL协议与数据结构</a></li><li class="chapter-item "><a href="documents/rknnlibso/overview.html"><strong aria-hidden="true">4.1.3.</strong> rknn用户库手册</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="documents/rknnlibso/rknn-api.html"><strong aria-hidden="true">4.1.3.1.</strong> 推理 API 参考</a></li><li class="chapter-item "><a href="documents/rknnlibso/rknn-matmul.html"><strong aria-hidden="true">4.1.3.2.</strong> 矩阵乘法 API</a></li><li class="chapter-item "><a href="documents/rknnlibso/custom-op.html"><strong aria-hidden="true">4.1.3.3.</strong> 自定义算子 API</a></li><li class="chapter-item "><a href="documents/rknnlibso/lifecycle.html"><strong aria-hidden="true">4.1.3.4.</strong> 模型推理全链条</a></li><li class="chapter-item "><a href="documents/rknnlibso/memory.html"><strong aria-hidden="true">4.1.3.5.</strong> 内存管理与零拷贝</a></li><li class="chapter-item "><a href="documents/rknnlibso/internals.html"><strong aria-hidden="true">4.1.3.6.</strong> 闭源库内部机制</a></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">StarryOS-pulsar-development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="这个pages展示本项目的开发计划和项目文档"><a class="header" href="#这个pages展示本项目的开发计划和项目文档">这个Pages展示本项目的开发计划和项目文档</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rk3588-npu-驱动开发路线图"><a class="header" href="#rk3588-npu-驱动开发路线图">RK3588 NPU 驱动开发路线图</a></h1>
<h2 id="进度总览"><a class="header" href="#进度总览">进度总览</a></h2>
<blockquote>
<p><strong>当前状态</strong>：电源域管理 (Power Domain)
<strong>目标</strong>：将添加了npu驱动的starry编译拷贝到开发板验证探测</p>
</blockquote>
<h2 id="实际计划"><a class="header" href="#实际计划">实际计划</a></h2>
<h2 id="第一周环境验证与基础初始化"><a class="header" href="#第一周环境验证与基础初始化">第一周：环境验证与基础初始化</a></h2>
<h3 id="1-理论与环境准备"><a class="header" href="#1-理论与环境准备">1. 理论与环境准备</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong>阅读手册与 Demo</strong>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
研读 RK3588 技术参考手册中 NPU 章节。</li>
<li><input disabled="" type="checkbox" checked=""/>
分析 RKNN Toolkit2 的官方 Demo，理解从模型加载到推理的完整数据流</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>实体机环境验证</strong> (基于 StarryOS 比赛版)
<ul>
<li><input disabled="" type="checkbox" checked=""/>
编译并烧录比赛版本的 StarryOS 代码到 RK3588 实体板。</li>
<li><input disabled="" type="checkbox" checked=""/>
成功运行一个简单的文本生成模型，确保硬件和工具链正常。</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>整理 StarryOS 对 RK3588 NPU 驱动的逆向成果</strong>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong>寄存器地图</strong>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
按模块梳理：PC / CORE / CNA / DPU / PPU / SDMA / DDMA / GLOBAL</li>
<li><input disabled="" type="checkbox" checked=""/>
对每个寄存器记录：offset、字段含义、读写属性、默认值/复位值、关联流程</li>
<li><input disabled="" type="checkbox" checked=""/>
标注来源：TRM / Linux rknpu 驱动</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>提交协议与数据结构</strong>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
整理 <code>DRM_IOCTL_RKNPU_*</code> ioctl 列表与语义（Action / MemCreate / MemMap / MemDestroy / MemSync / Submit）</li>
<li><input disabled="" type="checkbox" checked=""/>
对齐结构体布局：<code>rknpu_mem_create</code> / <code>rknpu_mem_map</code> / <code>rknpu_task</code> / <code>rknpu_submit</code>（字段意义与对齐）</li>
<li><input disabled="" type="checkbox" checked=""/>
梳理 <code>mmap(offset)</code> 规则（handle 与 offset 的编码/解码约定）</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>任务提交流程（时序 + 状态机）</strong>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
从“用户态提交”到“硬件执行完成”的完整时序</li>
<li><input disabled="" type="checkbox" checked=""/>
失败路径：超时、异常中断状态、非法参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-驱动框架搭建-在starryos主线上完成"><a class="header" href="#2-驱动框架搭建-在starryos主线上完成">2. 驱动框架搭建 (在StarryOS主线上完成)</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong>创建模块骨架</strong>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
在StarryOS组织的<code>arceos</code> 仓库中创建 <code>rknpu</code> 独立模块。</li>
<li><input disabled="" type="checkbox" checked=""/>
配置 <code>Cargo.toml</code> 依赖。</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>NPU探测</strong>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
实现 FDT (设备树) 解析，获取 NPU 寄存器基地址和中断号。</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<strong>电源域管理 (Power Domain)</strong>
<ul>
<li><input disabled="" type="checkbox"/>
对接 PMU 驱动，按顺序开启 NPU 电源域：
<ul>
<li><input disabled="" type="checkbox"/>
<code>NPUTOP</code></li>
<li><input disabled="" type="checkbox"/>
<code>NPU0</code> (Core 0)</li>
<li><input disabled="" type="checkbox"/>
<code>NPU1</code> (Core 1)</li>
<li><input disabled="" type="checkbox"/>
<code>NPU2</code> (Core 2)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-用户态接口适配-drm"><a class="header" href="#3-用户态接口适配-drm">3. 用户态接口适配 (DRM)</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>DRM 框架（StarryOS 主线）</strong>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>DRM ioctl 基础解析</strong>
<ul>
<li><input disabled="" type="checkbox"/>
实现 ioctl 编码解析：<code>ioctl_nr</code> / <code>is_driver_ioctl</code> / <code>io_size</code></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<strong>设备节点与基础握手</strong>
<ul>
<li><input disabled="" type="checkbox"/>
<code>/dev/dri/card0</code>：实现 <code>DRM_IOCTL_VERSION</code>，返回 Rockchip 相关信息以通过初始化探测</li>
<li><input disabled="" type="checkbox"/>
<code>/dev/dri/card1</code>：实现 <code>DRM_IOCTL_VERSION</code>，driver name 为 <code>rknpu</code></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<strong>RKNPU driver ioctls（初期基于闭源库验证成果）</strong>
<ul>
<li><input disabled="" type="checkbox"/>
<code>DRM_IOCTL_RKNPU_MEM_CREATE</code>：返回 handle + dma_addr（设备可访问地址）</li>
<li><input disabled="" type="checkbox"/>
<code>DRM_IOCTL_RKNPU_MEM_MAP</code>：返回可用于 <code>mmap</code> 的 offset</li>
<li><input disabled="" type="checkbox"/>
<code>mmap</code>：根据 offset 找回 handle，并映射出可读写的用户态地址</li>
<li><input disabled="" type="checkbox"/>
<code>DRM_IOCTL_RKNPU_SUBMIT</code>：最小可用的同步提交（先跑通）</li>
<li><input disabled="" type="checkbox"/>
<code>DRM_IOCTL_RKNPU_MEM_DESTROY</code>：释放 handle 对应的内存对象（避免泄漏）</li>
<li><input disabled="" type="checkbox"/>
<code>DRM_IOCTL_RKNPU_MEM_SYNC</code>：实现 cache sync 语义（至少对常用 flags 生效）</li>
<li><input disabled="" type="checkbox"/>
<code>DRM_IOCTL_RKNPU_ACTION</code>：实现最小集合（GetDrvVersion/GetHwVersion/ActReset/GetIommuEn）</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<strong>基于逆向成果编写纯驱动（内核态自测），再次验证上述成果</strong>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>目标</strong>：不靠 <code>librknnrt.so</code>，自己在内核里“拼出一份 NPU 能执行的命令”，跑通一次计算</li>
<li><input disabled="" type="checkbox"/>
<strong>待完成</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="第二周核心逻辑与任务提交"><a class="header" href="#第二周核心逻辑与任务提交">第二周：核心逻辑与任务提交</a></h2>
<h3 id="1-硬件抽象层-hal"><a class="header" href="#1-硬件抽象层-hal">1. 硬件抽象层 (HAL)</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>寄存器定义</strong>
<ul>
<li><input disabled="" type="checkbox"/>
封装 NPU 控制寄存器 (PC_DATA, PC_TASK_CONTROL 等)。</li>
<li><input disabled="" type="checkbox"/>
封装中断状态寄存器 (INT_STATUS, INT_CLEAR)。</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<strong>低级操作封装</strong>
<ul>
<li><input disabled="" type="checkbox"/>
实现 <code>npu_reset()</code> (软复位)。</li>
<li><input disabled="" type="checkbox"/>
实现 <code>npu_start()</code> (启动计算)。</li>
</ul>
</li>
</ul>
<h3 id="2-任务调度逻辑"><a class="header" href="#2-任务调度逻辑">2. 任务调度逻辑</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>IOCTL 接口对接</strong>
<ul>
<li><input disabled="" type="checkbox"/>
在 <code>StarryOS</code> 中处理来自 <code>card1</code> 的 IOCTL 请求。</li>
<li><input disabled="" type="checkbox"/>
解析用户态传递的 <code>RKNPU_SUBMIT</code> 结构体。</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<strong>任务提交 (Job Submission)</strong>
<ul>
<li><input disabled="" type="checkbox"/>
申请内核 DMA 内存存放 Command Buffer。</li>
<li><input disabled="" type="checkbox"/>
将用户态指令流写入硬件寄存器。</li>
<li><input disabled="" type="checkbox"/>
触发 NPU 硬件运行。</li>
<li><input disabled="" type="checkbox"/>
任务完成判定：中断状态位/完成标志的明确化（文档与代码一致）</li>
<li><input disabled="" type="checkbox"/>
超时与异常路径：可观测日志 + 合理错误码</li>
<li><input disabled="" type="checkbox"/>
多核最小策略：至少支持 core0/core1/core2 单核提交与轮转</li>
</ul>
</li>
</ul>
<hr />
<h2 id="待定计划-backlog"><a class="header" href="#待定计划-backlog">待定计划 (Backlog)</a></h2>
<blockquote>
<p><em>随着开发深入，以下内容将补充细节</em></p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>中断处理 (IRQ Handler)</strong>：实现异步等待机制，替代轮询。</li>
<li><input disabled="" type="checkbox"/>
<strong>IOMMU/SMMU 支持</strong>：实现虚实地址转换，支持非连续内存。</li>
<li><input disabled="" type="checkbox"/>
<strong>多核调度策略</strong>：如何分配任务给 3 个 NPU 核心。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目周报"><a class="header" href="#项目周报">项目周报</a></h1>
<p>按周记录 RKNN NPU 驱动开发进展。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一周开发日志"><a class="header" href="#第一周开发日志">第一周开发日志</a></h1>
<h2 id="工作总结"><a class="header" href="#工作总结">工作总结</a></h2>
<p>这周完成了 NPU 驱动开发的准备工作，包括开发板验证、闭源库逆向文档整理、驱动骨架搭建。内容如下：
<strong>开发板验证通过</strong> — 在 OrangePi 5 Plus（RK3588）上部署 StarryOS（NPU 版本），成功跑通 RKNN 推理测例
<strong>闭源库逆向文档整理</strong> — 整理了 <code>librknnrt.so</code> 逆向成果、完整寄存器语义、模型推理全链条，发布至 <a href="https://qc-gpu-driver.github.io/starryos-pulsar/documents/docs.html">GitHub Pages</a>
<strong>驱动骨架搭建</strong> — 创建 <code>axnpu-rknn</code> 独立 crate，编写 DTB 设备探测代码（<code>dtbparse.rs</code>），通过 <code>rdrive</code> 框架自动匹配 <code>rockchip,rk3588-rknn</code>
<strong>基础知识补充</strong> — 学习 NPU 原理、AI 模型本质、RKNN Toolkit2 套件与仿真器</p>
<hr />
<h2 id="开发板验证"><a class="header" href="#开发板验证">开发板验证</a></h2>
<p>搭载 RK3588 芯片的 <strong>OrangePi 5 Plus</strong> 开发板到了之后，将带有 NPU 支持的 StarryOS 版本（<a href="https://atomgit.com/aios-porting/3906cf9f2ccbf898bd3512d5862ef92e">atomgit 仓库</a>）部署到开发板上，<strong>成功跑通测例</strong>，验证了 NPU 驱动在 StarryOS 上的可行性。</p>
<hr />
<h2 id="闭源库逆向与文档整理"><a class="header" href="#闭源库逆向与文档整理">闭源库逆向与文档整理</a></h2>
<p>花了 3 天时间系统整理了以下内容：</p>
<ul>
<li><strong><code>librknnrt.so</code> 闭源库逆向成果</strong> — 梳理了用户态库的内部调用流程、ioctl 命令、内存管理机制</li>
<li><strong>寄存器语义</strong> — 从官方 TRM 手册和 <a href="https://github.com/rockchip-linux/kernel">RKNN 开源内核驱动</a>（C 语言版本）中，整理了完整的寄存器描述和语义</li>
<li><strong>模型推理全链条</strong> — 从 <code>rknn_init</code> 到 <code>rknn_destroy</code> 的完整生命周期，包括任务提交流程、状态机、DMA Fence 路径等</li>
</ul>
<blockquote>
<p><strong>文档链接</strong>：<a href="https://qc-gpu-driver.github.io/starryos-pulsar/documents/docs.html">https://qc-gpu-driver.github.io/starryos-pulsar/documents/docs.html</a></p>
</blockquote>
<p>这份文档不仅方便自己开发时查阅，也相当于一份<strong>社区参考文档</strong>，我也会一直维护和验证的，方便更多对 RKNN NPU 驱动感兴趣的开发者查阅和使用。</p>
<hr />
<h2 id="驱动骨架编写"><a class="header" href="#驱动骨架编写">驱动骨架编写</a></h2>
<p>最初尝试直接在 <code>arceos/modules/</code> 下创建 <code>axnpu-rknn</code> 驱动模块，但遇到了较多的<strong>循环依赖问题</strong>（<code>axdriver → axfs → axmm → axdma → axdriver</code>），参考 StarryOS（NPU 版本）的做法，将驱动模块移动到 Starry 根目录下独立开发，等完善后再集成回 arceos。</p>
<p>编写了 <code>dtbparse.rs</code>，利用 ArceOS 的 <code>rdrive</code> 框架通过设备树（DTB）自动探测 NPU 设备：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module_driver! {
    name: "RKNPU",
    level: ProbeLevel::PostKernel,
    priority: ProbePriority::DEFAULT,
    probe_kinds: &amp;[
        ProbeKind::Fdt {
            compatibles: &amp;["rockchip,rk3588-rknn"],
            on_probe: probe_rknpu
        }
    ],
}

fn probe_rknpu(info: FdtInfo&lt;'_&gt;, dev: PlatformDevice) -&gt; Result&lt;(), OnProbeError&gt; {
    let name = info.node.name();
    // 提取 MMIO 基址: 0xfdab0000, 大小: 0x9000
    let mut regs = info.node.reg().ok_or_else(|| { /* ... */ })?;
    let base_reg = regs.next().ok_or_else(|| { /* ... */ })?;
    let mmio_base = base_reg.address as usize;
    let mmio_size = base_reg.size.unwrap_or(0x9000);
    // 提取中断号: SPI 110, 111, 112（3 个 NPU 核心）
    // ...
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><code>module_driver!</code> 宏会将驱动自动注册到 <code>rdrive</code> 框架，内核启动时遍历 DTB，匹配 <code>compatible = "rockchip,rk3588-rknn"</code> 后自动调用 <code>probe_rknpu</code>，无需手动调用。</p>
<hr />
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<p>刚接到 NPU 驱动开发任务时，虽然听说过 NPU，但对它实际是什么、解决什么问题、工作原理、如何运行都不了解。花了一天时间系统学习了以下内容：</p>
<ul>
<li><strong>NPU 是什么</strong> — 神经网络处理单元，专为矩阵运算和推理加速设计的硬件</li>
<li><strong>AI 模型的本质</strong> — 本质上是一个函数,是大量矩阵乘法配上激活函数。训练是拟合参数，推理是执行前向传播</li>
<li><strong>模型格式与转换</strong> — ONNX → RKNN 格式转换，量化，以及模型在 NPU 上的执行流程</li>
<li><strong>驱动在整个链条中的角色</strong> — 用户态库（<code>librknnrt.so</code>）通过 ioctl 与内核驱动通信，驱动负责任务调度、DMA 搬运、寄存器操作</li>
</ul>
<p>上 Rockchip 官网下载了 <a href="https://github.com/airockchip/rknn-toolkit2">rknn-toolkit2</a> 套件，发现里面包含一个 <strong>仿真器</strong>，可以在 x86 主机上模拟 RKNPU 的部分功能。阅读了 demo 代码，理解了 RKNN 推理的基本 API 调用流程：</p>
<pre><code>rknn_init()来初始化npu执行上下文 → rknn_inputs_set()读写npu寄存器设置输出输出参数 → rknn_run()写npu寄存器提醒npu开始工作和运行 → rknn_outputs_get()npu通过中断通知操作系统，用户库从约定位置读取结果 → rknn_destroy()销毁释放npu执行上下文
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="rk3588-rknpu-开发文档"><a class="header" href="#rk3588-rknpu-开发文档">RK3588 RKNPU 开发文档</a></h1>
<p>本文档基于 RockChip官方开源仓库和 StarryOS 仓库中对 RK3588 NPU 运行时库（闭源 <code>librknnrt.so</code>）及内核侧 RKNPU DRM 驱动的逆向与复现成果，整理为三个核心章节：</p>
<h2 id="文档结构"><a class="header" href="#文档结构">文档结构</a></h2>
<table>
<tr>
<th>章节</th><th>内容</th><th>适用场景</th>
</tr>
<tr>
<td><a href="documents/./rknn-feature.html"><strong>RKNN 硬件特性</strong></a></td>
<td>三核架构、数据精度与算力、支持的推理框架</td>
<td>了解硬件能力边界</td>
</tr>
<tr>
<td><a href="documents/./register-map.html"><strong>寄存器地图</strong></a></td>
<td>按模块梳理rknpu内部各个寄存器的位域、读写属性</td>
<td>写驱动、调试硬件交互</td>
</tr>
<tr>
<td><a href="documents/./ioctl-protocol.html"><strong>IOCTL协议与数据结构</strong></a></td>
<td>DRM_IOCTL_RKNPU_* 命令表，结构体布局，flags枚举，mmap 规则</td>
<td>实现ioctl分发，对齐用户态ABI</td>
</tr>
<tr>
<td><a href="documents/./submit-flow.html"><strong>任务提交流程</strong></a></td>
<td>从用户态提交到硬件执行完成的完整时序逻辑，包含状态机和各种失败路径</td>
<td>查询job生命周期</td>
</tr>
</table>
<h2 id="来源标注约定"><a class="header" href="#来源标注约定">来源标注约定</a></h2>
<p>文档中对每条信息标注来源，使用以下标记：</p>
<ul>
<li><span style="background:#e8f5e9;padding:2px 6px;border-radius:3px;font-size:0.85em">Linux rknpu 驱动</span> — 来自Rockchip官方仓库中rk3588-npu内核驱动代码</li>
<li><span style="background:#e3f2fd;padding:2px 6px;border-radius:3px;font-size:0.85em">rknpu-ioctl.h</span> — 来自 Linux rknpu 驱动include目录的 ioctl 头文件</li>
<li><span style="background:#fff3e0;padding:2px 6px;border-radius:3px;font-size:0.85em">StarryOS Rust 驱动</span> — 来自 <code>drivers/rknpu/src/</code> 的 Rust 复刻实现</li>
<li><span style="background:#fce4ec;padding:2px 6px;border-radius:3px;font-size:0.85em">逆向推断</span> — 基于代码行为推断，无官方文档确认</li>
</ul>
<h2 id="术语速查"><a class="header" href="#术语速查">术语速查</a></h2>
<div class="table-wrapper"><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody>
<tr><td><strong>GEM</strong></td><td>Graphics Execution Manager，DRM 子系统的内存对象管理框架</td></tr>
<tr><td><strong>PC</strong></td><td>Program Counter / 任务控制器，NPU 的命令流执行引擎</td></tr>
<tr><td><strong>CNA</strong></td><td>Convolution Neural-network Accelerator，卷积加速单元</td></tr>
<tr><td><strong>DPU</strong></td><td>Data Processing Unit，数据后处理单元</td></tr>
<tr><td><strong>PPU</strong></td><td>Pooling Processing Unit，池化处理单元</td></tr>
<tr><td><strong>DDMA/SDMA</strong></td><td>Data DMA / System DMA，数据搬运引擎</td></tr>
<tr><td><strong>IOVA</strong></td><td>I/O Virtual Address，IOMMU 映射后的设备侧虚拟地址</td></tr>
<tr><td><strong>fence</strong></td><td>DMA fence，用于 job 完成通知与跨设备同步的内核原语</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rknn-手册"><a class="header" href="#rknn-手册">RKNN 手册</a></h1>
<p>本栏汇总 RK3588 NPU 的硬件参考与软件接口文档。</p>
<h2 id="硬件手册"><a class="header" href="#硬件手册">硬件手册</a></h2>
<p>NPU 三核架构、数据精度、寄存器位域详解。</p>
<p><a href="documents/./rknn-hardware.html">硬件手册</a></p>
<h2 id="ioctl-协议"><a class="header" href="#ioctl-协议">IOCTL 协议</a></h2>
<p>DRM_IOCTL_RKNPU_* 命令表、结构体布局、mmap 规则。</p>
<p><a href="documents/./ioctl-protocol.html">IOCTL 协议</a></p>
<h2 id="任务提交流程"><a class="header" href="#任务提交流程">任务提交流程</a></h2>
<p>从用户态提交到硬件执行完成的完整时序。</p>
<p><a href="documents/./submit-flow.html">任务提交流程</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rknn-硬件手册"><a class="header" href="#rknn-硬件手册">RKNN 硬件手册</a></h1>
<blockquote>
<p>来源：RK3588 TRM Chapter 36 RKNN</p>
</blockquote>
<p>本章汇总 RK3588 NPU 硬件相关文档，包括硬件特性概览与完整寄存器参考。</p>
<h2 id="rknn-硬件特性"><a class="header" href="#rknn-硬件特性">RKNN 硬件特性</a></h2>
<ul>
<li>三核 NPU，支持三核协同 / 双核协同 / 单核独立</li>
<li>每核 384KB 内部缓冲，AHB 配置接口 + AXI 数据接口</li>
<li>支持 INT4 / INT8 / INT16 / FP16 / BF16 / TF32 多精度推理</li>
<li>功能流水线：CNA（卷积）→ CORE（MAC）→ DPU（后处理）→ PPU（池化）</li>
<li>激活函数：ReLU / Leaky ReLU / ReLUx / Sigmoid / Tanh / Softmax</li>
<li>池化：Average / Max / Min Pooling</li>
</ul>
<p><a href="documents/./rknn-feature.html">完整硬件特性</a></p>
<h2 id="寄存器图"><a class="header" href="#寄存器图">寄存器图</a></h2>
<p>每个核心拥有独立 64KB 寄存器空间，按功能模块划分：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">模块</th><th style="text-align: center">地址范围</th><th style="text-align: left">功能</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>PC</strong></td><td style="text-align: center"><code>0x0000 ~ 0x0FFF</code></td><td style="text-align: left">任务控制器 / 命令流引擎</td></tr>
<tr><td style="text-align: center"><strong>CNA</strong></td><td style="text-align: center"><code>0x1000 ~ 0x1FFF</code></td><td style="text-align: left">卷积神经网络加速单元</td></tr>
<tr><td style="text-align: center"><strong>CORE</strong></td><td style="text-align: center"><code>0x3000 ~ 0x3FFF</code></td><td style="text-align: left">MAC 核心控制</td></tr>
<tr><td style="text-align: center"><strong>DPU</strong></td><td style="text-align: center"><code>0x4000 ~ 0x4FFF</code></td><td style="text-align: left">数据后处理单元</td></tr>
<tr><td style="text-align: center"><strong>DPU_RDMA</strong></td><td style="text-align: center"><code>0x5000 ~ 0x5FFF</code></td><td style="text-align: left">DPU 读 DMA</td></tr>
<tr><td style="text-align: center"><strong>PPU</strong></td><td style="text-align: center"><code>0x6000 ~ 0x6FFF</code></td><td style="text-align: left">池化处理单元</td></tr>
<tr><td style="text-align: center"><strong>PPU_RDMA</strong></td><td style="text-align: center"><code>0x7000 ~ 0x7FFF</code></td><td style="text-align: left">PPU 读 DMA</td></tr>
<tr><td style="text-align: center"><strong>DDMA</strong></td><td style="text-align: center"><code>0x8000 ~ 0x8FFF</code></td><td style="text-align: left">Data DMA 引擎</td></tr>
<tr><td style="text-align: center"><strong>SDMA</strong></td><td style="text-align: center"><code>0x9000 ~ 0x9FFF</code></td><td style="text-align: left">System DMA 引擎</td></tr>
<tr><td style="text-align: center"><strong>GLOBAL</strong></td><td style="text-align: center"><code>0xF000 ~ 0xFFFF</code></td><td style="text-align: left">全局使能掩码</td></tr>
</tbody></table>
</div>
<p><a href="documents/./register-map.html">寄存器总览</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rknn-硬件特性概览"><a class="header" href="#rknn-硬件特性概览">RKNN 硬件特性概览</a></h1>
<blockquote>
<p>来源：RK3588 TRM Chapter 36 RKNN</p>
</blockquote>
<p>RKNN 是专用于神经网络的处理单元，旨在加速人工智能（AI）领域的神经网络运算，涵盖机器视觉和自然语言处理等方向。AI 的应用范围正在不断扩大，目前已在多个领域提供功能支持，包括人脸追踪、手势与肢体追踪、图像分类、视频监控、自动语音识别（ASR）以及高级驾驶辅助系统（ADAS）。</p>
<h2 id="核心特性"><a class="header" href="#核心特性">核心特性</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody>
<tr><td><strong>核心数量</strong></td><td>三核 NPU（Triple NPU CORE）</td></tr>
<tr><td><strong>协作模式</strong></td><td>支持三核协同、双核协同、单核独立工作</td></tr>
<tr><td><strong>配置接口</strong></td><td>AHB 接口，仅用于寄存器配置（单次访问）</td></tr>
<tr><td><strong>数据接口</strong></td><td>AXI 接口，用于从内存取数据</td></tr>
<tr><td><strong>内部缓冲</strong></td><td>384KB × 3（每核 384KB）</td></tr>
</tbody></table>
</div>
<p><img src="documents/./images/core.png" alt="rknn多核架构参考图" />
<img src="documents/./images/signalcore.png" alt="rknn单个核心架构参考图" /></p>
<h2 id="功能模块描述"><a class="header" href="#功能模块描述">功能模块描述</a></h2>
<h3 id="ahb--axi-接口"><a class="header" href="#ahb--axi-接口">AHB / AXI 接口</a></h3>
<p>AXI 主接口用于从挂载在 SoC AXI 互联总线上的内存中取数据。AHB 从接口用于访问寄存器，进行配置、调试和测试。</p>
<h3 id="神经网络加速引擎neural-network-accelerating-engine"><a class="header" href="#神经网络加速引擎neural-network-accelerating-engine">神经网络加速引擎（Neural Network Accelerating Engine）</a></h3>
<p>该引擎是神经网络运算的核心处理单元，包含卷积预处理控制器、内部缓冲区、MAC 阵列和累加器。它为识别功能提供并行卷积 MAC 运算，支持 INT4、INT8、INT16、FP16、BF16 和 TF32 数据类型。</p>
<h3 id="数据处理单元data-processing-unit-dpu"><a class="header" href="#数据处理单元data-processing-unit-dpu">数据处理单元（Data Processing Unit, DPU）</a></h3>
<p>数据处理单元主要负责单数据运算，如 Leaky ReLU、ReLU、ReLUx、Sigmoid、Tanh 等激活函数。同时提供 Softmax、转置（Transpose）、数据格式转换等功能。</p>
<h3 id="平面处理单元planar-processing-unit-ppu"><a class="header" href="#平面处理单元planar-processing-unit-ppu">平面处理单元（Planar Processing Unit, PPU）</a></h3>
<p>平面处理单元在数据处理单元输出之后执行平面操作，支持平均池化（Average Pooling）、最大池化（Max Pooling）、最小池化（Min Pooling）等。</p>
<h3 id="寄存器配置取数单元register-file-fetch-unit-pc"><a class="header" href="#寄存器配置取数单元register-file-fetch-unit-pc">寄存器配置取数单元（Register File Fetch Unit, PC）</a></h3>
<p>寄存器配置取数单元通过 AXI 接口从外部系统内存中获取寄存器配置（即命令流），实现硬件自动配置各功能模块寄存器。</p>
<h2 id="支持的数据精度与算力"><a class="header" href="#支持的数据精度与算力">支持的数据精度与算力</a></h2>
<div class="table-wrapper"><table><thead><tr><th>数据类型</th><th>每周期 MAC 操作数（三核合计）</th></tr></thead><tbody>
<tr><td><strong>INT4</strong></td><td>2048 × 3 = 6144</td></tr>
<tr><td><strong>INT8</strong></td><td>1024 × 3 = 3072</td></tr>
<tr><td><strong>INT16</strong></td><td>512 × 3 = 1536</td></tr>
<tr><td><strong>FP16</strong></td><td>512 × 3 = 1536</td></tr>
<tr><td><strong>BF16</strong></td><td>512 × 3 = 1536</td></tr>
<tr><td><strong>TF32</strong></td><td>256 × 3 = 768</td></tr>
</tbody></table>
</div>
<h2 id="支持的推理框架"><a class="header" href="#支持的推理框架">支持的推理框架</a></h2>
<p>TensorFlow、Caffe、TFLite、PyTorch、ONNX NN、Android NN 等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="寄存器地图"><a class="header" href="#寄存器地图">寄存器地图</a></h1>
<p>RK3588 NPU 每个核心（共 3 核）拥有独立的寄存器空间，内部按功能模块划分为以下区域：</p>
<h2 id="地址空间总览"><a class="header" href="#地址空间总览">地址空间总览</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Base[15:12]</th><th style="text-align: center">模块</th><th style="text-align: center">大小</th><th style="text-align: center">地址范围</th><th style="text-align: left">功能</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>4'h0</code></td><td style="text-align: center"><strong>PC</strong></td><td style="text-align: center">4KB</td><td style="text-align: center"><code>0x0000 ~ 0x0FFF</code></td><td style="text-align: left">任务控制器 / 命令流引擎</td></tr>
<tr><td style="text-align: center"><code>4'h1</code></td><td style="text-align: center"><strong>CNA</strong></td><td style="text-align: center">4KB</td><td style="text-align: center"><code>0x1000 ~ 0x1FFF</code></td><td style="text-align: left">卷积神经网络加速单元</td></tr>
<tr><td style="text-align: center"><code>4'h3</code></td><td style="text-align: center"><strong>CORE</strong></td><td style="text-align: center">4KB</td><td style="text-align: center"><code>0x3000 ~ 0x3FFF</code></td><td style="text-align: left">MAC 核心控制</td></tr>
<tr><td style="text-align: center"><code>4'h4</code></td><td style="text-align: center"><strong>DPU</strong></td><td style="text-align: center">4KB</td><td style="text-align: center"><code>0x4000 ~ 0x4FFF</code></td><td style="text-align: left">数据后处理单元</td></tr>
<tr><td style="text-align: center"><code>4'h5</code></td><td style="text-align: center"><strong>DPU_RDMA</strong></td><td style="text-align: center">4KB</td><td style="text-align: center"><code>0x5000 ~ 0x5FFF</code></td><td style="text-align: left">DPU 读 DMA</td></tr>
<tr><td style="text-align: center"><code>4'h6</code></td><td style="text-align: center"><strong>PPU</strong></td><td style="text-align: center">4KB</td><td style="text-align: center"><code>0x6000 ~ 0x6FFF</code></td><td style="text-align: left">池化处理单元</td></tr>
<tr><td style="text-align: center"><code>4'h7</code></td><td style="text-align: center"><strong>PPU_RDMA</strong></td><td style="text-align: center">4KB</td><td style="text-align: center"><code>0x7000 ~ 0x7FFF</code></td><td style="text-align: left">PPU 读 DMA</td></tr>
<tr><td style="text-align: center"><code>4'h8</code></td><td style="text-align: center"><strong>DDMA</strong></td><td style="text-align: center">4KB</td><td style="text-align: center"><code>0x8000 ~ 0x8FFF</code></td><td style="text-align: left">Data DMA 引擎</td></tr>
<tr><td style="text-align: center"><code>4'h9</code></td><td style="text-align: center"><strong>SDMA</strong></td><td style="text-align: center">4KB</td><td style="text-align: center"><code>0x9000 ~ 0x9FFF</code></td><td style="text-align: left">System DMA 引擎</td></tr>
<tr><td style="text-align: center"><code>4'hF</code></td><td style="text-align: center"><strong>GLOBAL</strong></td><td style="text-align: center">4B</td><td style="text-align: center"><code>0xF000 ~ 0xF004</code></td><td style="text-align: left">全局使能掩码</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>来源说明</strong>：地址映射来自 <span style="background:#e8f5e9;padding:1px 4px;border-radius:3px;font-size:0.85em">RK3588 TRM</span> Table 1-1 RKNN Address Mapping。</p>
</blockquote>
<hr />
<ul>
<li><a href="documents/registers/pc.html">PC（任务控制器）</a></li>
<li><a href="documents/registers/cna.html">CNA（卷积加速）</a></li>
<li><a href="documents/registers/core.html">CORE（MAC 核心）</a></li>
<li><a href="documents/registers/dpu.html">DPU（数据后处理）</a></li>
<li><a href="documents/registers/dpu-rdma.html">DPU_RDMA</a></li>
<li><a href="documents/registers/ppu.html">PPU（池化）</a></li>
<li><a href="documents/registers/ppu-rdma.html">PPU_RDMA</a></li>
<li><a href="documents/registers/ddma-sdma.html">DDMA / SDMA</a></li>
<li><a href="documents/registers/global.html">GLOBAL（全局使能）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pc-寄存器块program-counter--任务控制器"><a class="header" href="#pc-寄存器块program-counter--任务控制器">PC 寄存器块（Program Counter / 任务控制器）</a></h1>
<p><strong>基址</strong>：<code>CORE_BASE + 0x0000</code>　｜　<strong>地址范围</strong>：<code>0x0000 ~ 0x0FFF</code></p>
<blockquote>
<p>来源：RK3588 TRM §36.4.3 Detail Registers Description</p>
</blockquote>
<p>PC 是 NPU 的命令流执行引擎，负责：从 DMA 地址读取寄存器命令流 → 按序写入各功能模块寄存器 → 触发执行 → 产生完成中断。</p>
<hr />
<h2 id="rknn_pc_operation_enable0x0008"><a class="header" href="#rknn_pc_operation_enable0x0008">RKNN_pc_operation_enable（0x0008）</a></h2>
<p>操作使能寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>op_en</code></td><td style="text-align: left">PC 操作使能。0：禁用 PC 模块；1：使能 PC 模块，为每个 task 取寄存器配置</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_pc_base_address0x0010"><a class="header" href="#rknn_pc_base_address0x0010">RKNN_pc_base_address（0x0010）</a></h2>
<p>PC 基址寄存器，指定 DMA 指令流所在的内存地址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pc_source_addr</code></td><td style="text-align: left">PC 基址。DMA 指令流所在的内存地址</td></tr>
<tr><td style="text-align: center">3:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pc_sel</code></td><td style="text-align: left">PC 模式选择。0：PC 模式，通过 AXI DMA 取寄存器配置；1：Slave 模式，通过 AHB 设置寄存器</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_pc_register_amounts0x0014"><a class="header" href="#rknn_pc_register_amounts0x0014">RKNN_pc_register_amounts（0x0014）</a></h2>
<p>每个 task 需要取的寄存器数量。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pc_data_amount</code></td><td style="text-align: left">数据量。一个 task 需要取的寄存器数量</td></tr>
</tbody></table>
</div>
<p>每条寄存器指令占 64 bit，格式如下：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">位域</th><th style="text-align: left">含义</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>[63:48]</code></td><td style="text-align: left">目标模块选择（哪个 block）</td></tr>
<tr><td style="text-align: center"><code>[47:16]</code></td><td style="text-align: left">寄存器值</td></tr>
<tr><td style="text-align: center"><code>[15:0]</code></td><td style="text-align: left">各 block 内的偏移地址</td></tr>
</tbody></table>
</div>
<p><strong>模块选择位</strong>：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: left">目标模块</th></tr></thead><tbody>
<tr><td style="text-align: center">56</td><td style="text-align: left">PC</td></tr>
<tr><td style="text-align: center">57</td><td style="text-align: left">CNA</td></tr>
<tr><td style="text-align: center">59</td><td style="text-align: left">CORE</td></tr>
<tr><td style="text-align: center">60</td><td style="text-align: left">DPU</td></tr>
<tr><td style="text-align: center">61</td><td style="text-align: left">DPU_RDMA</td></tr>
<tr><td style="text-align: center">62</td><td style="text-align: left">PPU</td></tr>
<tr><td style="text-align: center">63</td><td style="text-align: left">PPU_RDMA</td></tr>
<tr><td style="text-align: center">55</td><td style="text-align: left">设置各 block 的 <code>op_en</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>示例</strong>：<code>64'h0081_0000_007f_0008</code> 将设置各 block 的 op_en（CNA, CORE, ..., PPU_RDMA）。</p>
<p><strong>注意</strong>：<code>op_en</code> 强烈建议放在寄存器列表末尾。在 <code>op_en</code> 之前，必须先设置 <code>64'h0041_xxxx_xxxx_xxxx</code>。</p>
</blockquote>
<hr />
<h2 id="rknn_pc_interrupt_mask0x0020"><a class="header" href="#rknn_pc_interrupt_mask0x0020">RKNN_pc_interrupt_mask（0x0020）</a></h2>
<p>中断掩码寄存器。置 1 使能对应中断。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x1FFFF</td><td style="text-align: left"><code>int_mask</code></td><td style="text-align: left">中断掩码（见下表）</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: left">中断源</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: left">CNA feature group 0</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: left">CNA feature group 1</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: left">CNA weight group 0</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: left">CNA weight group 1</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: left">CNA csc group 0</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: left">CNA csc group 1</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: left">CORE group 0</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: left">CORE group 1</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: left">DPU group 0</td></tr>
<tr><td style="text-align: center">9</td><td style="text-align: left">DPU group 1</td></tr>
<tr><td style="text-align: center">10</td><td style="text-align: left">PPU group 0</td></tr>
<tr><td style="text-align: center">11</td><td style="text-align: left">PPU group 1</td></tr>
<tr><td style="text-align: center">12</td><td style="text-align: left">DMA read error</td></tr>
<tr><td style="text-align: center">13</td><td style="text-align: left">DMA write error</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>注意</strong>：在 PC 模式下，int_mask 设置的是最后一个 task 的中断掩码。</p>
</blockquote>
<hr />
<h2 id="rknn_pc_interrupt_clear0x0024"><a class="header" href="#rknn_pc_interrupt_clear0x0024">RKNN_pc_interrupt_clear（0x0024）</a></h2>
<p>中断清除寄存器。写 1 清除对应中断位。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16:0</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>int_clr</code></td><td style="text-align: left">中断清除（位定义同 <code>int_mask</code>）</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong><code>INT_CLEAR_ALL = 0x1FFFF</code></strong>（清除 bit0~bit16 全部中断）<span style="background:#e3f2fd;padding:1px 4px;border-radius:3px;font-size:0.8em">rknpu-ioctl.h</span></p>
</blockquote>
<hr />
<h2 id="rknn_pc_interrupt_status0x0028"><a class="header" href="#rknn_pc_interrupt_status0x0028">RKNN_pc_interrupt_status（0x0028）</a></h2>
<p>中断状态寄存器（经过 mask 后的状态）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16:0</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>int_st</code></td><td style="text-align: left">中断状态，与 mask 位做 AND（位定义同 <code>int_mask</code>）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_pc_interrupt_raw_status0x002c"><a class="header" href="#rknn_pc_interrupt_raw_status0x002c">RKNN_pc_interrupt_raw_status（0x002C）</a></h2>
<p>中断原始状态寄存器（未经 mask 的原始状态）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16:0</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>int_raw_st</code></td><td style="text-align: left">中断原始状态（位定义同 <code>int_mask</code>）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_pc_task_con0x0030"><a class="header" href="#rknn_pc_task_con0x0030">RKNN_pc_task_con（0x0030）</a></h2>
<p>任务控制寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:14</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">13</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>task_count_clear</code></td><td style="text-align: left">任务计数器清除。清除当前 task 计数器，建议在 task 启动前清除</td></tr>
<tr><td style="text-align: center">12</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>task_pp_en</code></td><td style="text-align: left">Ping-pong 模式使能。0：关闭，第二组寄存器在第一组 task 完成后才取；1：开启，第二组寄存器在第一组取完后立即开始取</td></tr>
<tr><td style="text-align: center">11:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>task_number</code></td><td style="text-align: left">要执行的 task 总数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_pc_task_dma_base_addr0x0034"><a class="header" href="#rknn_pc_task_dma_base_addr0x0034">RKNN_pc_task_dma_base_addr（0x0034）</a></h2>
<p>任务 DMA 基址寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dma_base_addr</code></td><td style="text-align: left">任务基址。各 DMA（feature DMA、weight DMA、DPU DMA、PPU DMA）的地址设为偏移地址，AXI 总线上的最终地址 = 基址 + 偏移地址</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_pc_task_status0x003c"><a class="header" href="#rknn_pc_task_status0x003c">RKNN_pc_task_status（0x003C）</a></h2>
<p>任务状态寄存器（只读）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:28</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">27:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>task_status</code></td><td style="text-align: left">任务状态（见下表）</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">位域</th><th style="text-align: left">含义</th></tr></thead><tbody>
<tr><td style="text-align: center">[11:0]</td><td style="text-align: left">当前 task 计数器值</td></tr>
<tr><td style="text-align: center">[12]</td><td style="text-align: left">指示第一个 task 正在执行 / 第一个 task 的寄存器正在取</td></tr>
<tr><td style="text-align: center">[13]</td><td style="text-align: left">指示最后一个 task 正在执行 / 最后一个 task 的寄存器正在取</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="附驱动层补充"><a class="header" href="#附驱动层补充">附：驱动层补充</a></h2>
<h3 id="中断状态归一化rknpu_fuzz_status"><a class="header" href="#中断状态归一化rknpu_fuzz_status">中断状态归一化（<code>rknpu_fuzz_status()</code>）</a></h3>
<p><span style="background:#fff3e0;padding:1px 4px;border-radius:3px;font-size:0.8em">StarryOS Rust 驱动</span> 在判定完成前，对 <code>interrupt_status</code> 做如下归一化处理：</p>
<div class="table-wrapper"><table><thead><tr><th>位组</th><th>掩码</th><th>归一化规则</th><th>对应模块</th></tr></thead><tbody>
<tr><td>bit[1:0]</td><td><code>0x03</code></td><td>任一非零 → 置 <code>0x03</code></td><td>CNA_FG</td></tr>
<tr><td>bit[3:2]</td><td><code>0x0C</code></td><td>任一非零 → 置 <code>0x0C</code></td><td>CNA_WG</td></tr>
<tr><td>bit[5:4]</td><td><code>0x30</code></td><td>任一非零 → 置 <code>0x30</code></td><td>CNA_CSC</td></tr>
<tr><td>bit[7:6]</td><td><code>0xC0</code></td><td>任一非零 → 置 <code>0xC0</code></td><td>CORE</td></tr>
<tr><td>bit[9:8]</td><td><code>0x300</code></td><td>任一非零 → 置 <code>0x300</code></td><td>DPU</td></tr>
<tr><td>bit[11:10]</td><td><code>0xC00</code></td><td>任一非零 → 置 <code>0xC00</code></td><td>PPU</td></tr>
</tbody></table>
</div>
<p><strong>含义</strong> <span style="background:#fce4ec;padding:1px 4px;border-radius:3px;font-size:0.8em">逆向推断</span>：每个功能模块有 2 个中断 bit（G0/G1），硬件可能只置其中一个，但驱动判定完成时需要两个都为 1，因此做归一化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cna-寄存器块convolution-neural-network-accelerator"><a class="header" href="#cna-寄存器块convolution-neural-network-accelerator">CNA 寄存器块（Convolution Neural-network Accelerator）</a></h1>
<p><strong>基址</strong>：<code>CORE_BASE + 0x1000</code>　｜　<strong>地址范围</strong>：<code>0x1000 ~ 0x1FFF</code></p>
<blockquote>
<p>来源：RK3588 TRM §36.4.3 Detail Registers Description</p>
</blockquote>
<p>CNA 是卷积加速单元，包含特征数据加载、权重加载、384KB 内部缓冲（CBUF）、序列扫描控制器（CSC）。</p>
<hr />
<h2 id="rknn_cna_s_status0x1000"><a class="header" href="#rknn_cna_s_status0x1000">RKNN_cna_s_status（0x1000）</a></h2>
<p>执行器状态寄存器（只读）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:18</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">17:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_1</code></td><td style="text-align: left">执行器 1 状态。0：空闲；1：正在执行；2：正在执行且执行器 1 等待执行；3：保留</td></tr>
<tr><td style="text-align: center">15:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_0</code></td><td style="text-align: left">执行器 0 状态。0：空闲；1：正在执行；2：正在执行且执行器 1 等待执行；3：保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_s_pointer0x1004"><a class="header" href="#rknn_cna_s_pointer0x1004">RKNN_cna_s_pointer（0x1004）</a></h2>
<p>寄存器组指针与 ping-pong 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer</code></td><td style="text-align: left">当前使用的寄存器组。0：执行器组 0；1：执行器组 1</td></tr>
<tr><td style="text-align: center">15:6</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_clear</code></td><td style="text-align: left">清除执行器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_clear</code></td><td style="text-align: left">清除寄存器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_mode</code></td><td style="text-align: left">Ping-pong 模式。0：按执行器切换（executer 0 完成后切到 1）；1：按指针切换（pointer 0 完成后切到 1）</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_en</code></td><td style="text-align: left">执行器组 ping-pong 使能。0：禁用；1：使能</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_en</code></td><td style="text-align: left">寄存器组 ping-pong 使能。0：禁用；1：使能</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer</code></td><td style="text-align: left">当前待设置的寄存器组。0：组 0；1：组 1</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_operation_enable0x1008"><a class="header" href="#rknn_cna_operation_enable0x1008">RKNN_cna_operation_enable（0x1008）</a></h2>
<p>操作使能寄存器。写入此寄存器将触发 CNA 模块开始执行。此寄存器及之后的寄存器均为 ping-pong 影子寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>op_en</code></td><td style="text-align: left">CNA 操作使能。0：禁用；1：使能</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_conv_con10x100c"><a class="header" href="#rknn_cna_conv_con10x100c">RKNN_cna_conv_con1（0x100C）</a></h2>
<p>卷积控制寄存器 1：精度、模式、反卷积等。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">30</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>nonalign_dma</code></td><td style="text-align: left">CNA DMA 非对齐模式。0：禁用；1：使能（ARGB 模式下请开启，使 DMA 连续取特征数据）</td></tr>
<tr><td style="text-align: center">29</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>group_line_off</code></td><td style="text-align: left">组行取数关闭。0：使能组行取数；1：禁用（仅影响取数效率）</td></tr>
<tr><td style="text-align: center">28:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>deconv</code></td><td style="text-align: left">反卷积使能。0：禁用；1：使能</td></tr>
<tr><td style="text-align: center">15:12</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>argb_in</code></td><td style="text-align: left">非对齐通道层控制。8：1 通道输入；9：2 通道；10：3 通道；11：4 通道</td></tr>
<tr><td style="text-align: center">11:10</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">9:7</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>proc_precision</code></td><td style="text-align: left">处理精度。0：int8；1：int16；2：fp16；3：bf16；6：int4；7：tf32</td></tr>
<tr><td style="text-align: center">6:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>in_precision</code></td><td style="text-align: left">输入精度。编码同 <code>proc_precision</code></td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>conv_mode</code></td><td style="text-align: left">卷积模式。0：直接卷积；3：深度可分离卷积（Depthwise）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_conv_con20x1010"><a class="header" href="#rknn_cna_conv_con20x1010">RKNN_cna_conv_con2（0x1010）</a></h2>
<p>卷积控制寄存器 2：kernel 分组、feature grain、CSC 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:24</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">23:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>kernel_group</code></td><td style="text-align: left">Kernel 分组数。int8 下 32 个 kernel 为 1 组，int16/fp16 下 16 个为 1 组。例：256 个 kernel，int8 下设为 256/32−1=7</td></tr>
<tr><td style="text-align: center">15:14</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">13:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>feature_grains</code></td><td style="text-align: left">卷积开始前需缓冲的特征数据行数。建议设为 y_stride + weight_height + 1</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>csc_wo_en</code></td><td style="text-align: left">权重扫描控制。0：使能 CSC 输出权重到 CORE；1：禁用</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>csc_do_en</code></td><td style="text-align: left">数据扫描控制。0：使能 CSC 输出特征数据到 CORE；1：禁用</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cmd_fifo_srst</code></td><td style="text-align: left">命令 FIFO 软复位（调试用）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_conv_con30x1014"><a class="header" href="#rknn_cna_conv_con30x1014">RKNN_cna_conv_con3（0x1014）</a></h2>
<p>卷积控制寄存器 3：多核模式、空洞卷积、反卷积步长、卷积步长。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">30:28</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>nn_mode</code></td><td style="text-align: left">多核协作模式。0：32×32（单核）；1：64×32；2：96×32；4：32×64；5：32×96。单核模式保持 0</td></tr>
<tr><td style="text-align: center">27:26</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">25:21</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>atrous_y_dilation</code></td><td style="text-align: left">空洞卷积 Y 方向膨胀值（列方向两像素间插入的 pad 数）</td></tr>
<tr><td style="text-align: center">20:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>atrous_x_dilation</code></td><td style="text-align: left">空洞卷积 X 方向膨胀值（行方向两像素间插入的 pad 数）。&gt;0 时启用空洞卷积</td></tr>
<tr><td style="text-align: center">15:14</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">13:11</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>deconv_y_stride</code></td><td style="text-align: left">反卷积 Y 步长</td></tr>
<tr><td style="text-align: center">10:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>deconv_x_stride</code></td><td style="text-align: left">反卷积 X 步长</td></tr>
<tr><td style="text-align: center">7:6</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">5:3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>conv_y_stride</code></td><td style="text-align: left">卷积 Y 步长</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>conv_x_stride</code></td><td style="text-align: left">卷积 X 步长</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_data_size00x1020"><a class="header" href="#rknn_cna_data_size00x1020">RKNN_cna_data_size0（0x1020）</a></h2>
<p>输入特征数据宽高。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:27</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">26:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>datain_width</code></td><td style="text-align: left">输入特征数据宽度</td></tr>
<tr><td style="text-align: center">15:11</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">10:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>datain_height</code></td><td style="text-align: left">输入特征数据高度</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_data_size10x1024"><a class="header" href="#rknn_cna_data_size10x1024">RKNN_cna_data_size1（0x1024）</a></h2>
<p>输入特征数据通道数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:30</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">29:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>datain_channel_real</code></td><td style="text-align: left">真实通道数。当输入通道不是 8（int8）或 4（int16/fp16）的整数倍时，设置此字段</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>datain_channel</code></td><td style="text-align: left">输入通道数。int8 须为 8 的整数倍；int16/fp16 须为 4 的整数倍</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_data_size20x1028"><a class="header" href="#rknn_cna_data_size20x1028">RKNN_cna_data_size2（0x1028）</a></h2>
<p>卷积后输出数据宽度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:11</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">10:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dataout_width</code></td><td style="text-align: left">卷积后数据宽度</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_data_size30x102c"><a class="header" href="#rknn_cna_data_size30x102c">RKNN_cna_data_size3（0x102C）</a></h2>
<p>卷积后输出数据 surface 模式与总像素数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:24</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">23:22</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>surf_mode</code></td><td style="text-align: left">Surface 串行模式。0/1：1 surf；2：2 surf；3：4 surf</td></tr>
<tr><td style="text-align: center">21:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dataout_atomics</code></td><td style="text-align: left">卷积后输出总像素数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_weight_size00x1030"><a class="header" href="#rknn_cna_weight_size00x1030">RKNN_cna_weight_size0（0x1030）</a></h2>
<p>权重总字节数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>weight_bytes</code></td><td style="text-align: left">本次卷积的权重总字节数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_weight_size10x1034"><a class="header" href="#rknn_cna_weight_size10x1034">RKNN_cna_weight_size1（0x1034）</a></h2>
<p>单个 kernel 的权重字节数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:19</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">18:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>weight_bytes_per_kernel</code></td><td style="text-align: left">单个 kernel 的权重字节数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_weight_size20x1038"><a class="header" href="#rknn_cna_weight_size20x1038">RKNN_cna_weight_size2（0x1038）</a></h2>
<p>Kernel 宽高与数量。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:29</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">28:24</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>weight_width</code></td><td style="text-align: left">Kernel 宽度</td></tr>
<tr><td style="text-align: center">23:21</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">20:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>weight_height</code></td><td style="text-align: left">Kernel 高度</td></tr>
<tr><td style="text-align: center">15:14</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">13:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>weight_kernels</code></td><td style="text-align: left">Kernel 数量</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_cbuf_con00x1040"><a class="header" href="#rknn_cna_cbuf_con00x1040">RKNN_cna_cbuf_con0（0x1040）</a></h2>
<p>CBUF（内部缓冲）控制寄存器 0：数据/权重复用、Bank 分配。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:14</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">13</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>weight_reuse</code></td><td style="text-align: left">权重数据复用使能。0：禁用；1：使能，直接从内部缓冲取权重</td></tr>
<tr><td style="text-align: center">12</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>data_reuse</code></td><td style="text-align: left">特征数据复用使能。0：禁用；1：使能，直接从内部缓冲取数据</td></tr>
<tr><td style="text-align: center">11</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">10:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>fc_data_bank</code></td><td style="text-align: left">FC 零跳过模式的特征数据 Bank 数。FC 零跳过模式设为 1，否则必须为 0</td></tr>
<tr><td style="text-align: center">7:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>weight_bank</code></td><td style="text-align: left">权重数据占用的 Bank 数。1：Bank 7；2：Bank 6-7；…；7：Bank 1-7</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>data_bank</code></td><td style="text-align: left">特征数据占用的 Bank 数。0：Bank 0；1：Bank 0-1；…；6：Bank 0-6</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_cbuf_con10x1044"><a class="header" href="#rknn_cna_cbuf_con10x1044">RKNN_cna_cbuf_con1（0x1044）</a></h2>
<p>CBUF 控制寄存器 1。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>data_entries</code></td><td style="text-align: left">存储一行特征图所需的 Bank 空间</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_cvt_con00x104c"><a class="header" href="#rknn_cna_cvt_con00x104c">RKNN_cna_cvt_con0（0x104C）</a></h2>
<p>输入转换控制寄存器 0：CVT 截断值、符号、舍入、旁路。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:28</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">27:22</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_truncate_3</code></td><td style="text-align: left">CVT 截断值 3</td></tr>
<tr><td style="text-align: center">21:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_truncate_2</code></td><td style="text-align: left">CVT 截断值 2</td></tr>
<tr><td style="text-align: center">15:10</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_truncate_1</code></td><td style="text-align: left">CVT 截断值 1</td></tr>
<tr><td style="text-align: center">9:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_truncate_0</code></td><td style="text-align: left">CVT 截断值 0</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>data_sign</code></td><td style="text-align: left">特征数据符号。0：无符号；1：有符号</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>round_type</code></td><td style="text-align: left">舍入类型。0：奇入偶不入；1：0.5 向上进 1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_type</code></td><td style="text-align: left">转换运算顺序。0：先乘后加；1：先加后乘</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_bypass</code></td><td style="text-align: left">旁路输入转换。0：使能 CVT；1：禁用 CVT</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_cvt_con10x1050"><a class="header" href="#rknn_cna_cvt_con10x1050">RKNN_cna_cvt_con1（0x1050）</a></h2>
<p>输入转换控制 1：第 1 通道的 scale 和 offset。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_scale0</code></td><td style="text-align: left">CVT 缩放 0（第 1 通道乘法操作数）</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_offset0</code></td><td style="text-align: left">CVT 偏移 0（第 1 通道加法操作数）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_cvt_con20x1054"><a class="header" href="#rknn_cna_cvt_con20x1054">RKNN_cna_cvt_con2（0x1054）</a></h2>
<p>输入转换控制 2：第 2 通道。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_scale1</code></td><td style="text-align: left">CVT 缩放 1（第 2 通道乘法操作数）</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_offset1</code></td><td style="text-align: left">CVT 偏移 1（第 2 通道加法操作数）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_cvt_con30x1058"><a class="header" href="#rknn_cna_cvt_con30x1058">RKNN_cna_cvt_con3（0x1058）</a></h2>
<p>输入转换控制 3：第 3 通道。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_scale2</code></td><td style="text-align: left">CVT 缩放 2（第 3 通道乘法操作数）</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_offset2</code></td><td style="text-align: left">CVT 偏移 2（第 3 通道加法操作数）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_cvt_con40x105c"><a class="header" href="#rknn_cna_cvt_con40x105c">RKNN_cna_cvt_con4（0x105C）</a></h2>
<p>输入转换控制 4：第 4 通道。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_scale3</code></td><td style="text-align: left">CVT 缩放 3（第 4 通道乘法操作数）</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_offset3</code></td><td style="text-align: left">CVT 偏移 3（第 4 通道加法操作数）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_fc_con00x1060"><a class="header" href="#rknn_cna_fc_con00x1060">RKNN_cna_fc_con0（0x1060）</a></h2>
<p>全连接零跳过控制 0。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>fc_skip_data</code></td><td style="text-align: left">FC 零跳过数据值（通常设为 0）</td></tr>
<tr><td style="text-align: center">15:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>fc_skip_en</code></td><td style="text-align: left">FC 零跳过使能。0：禁用；1：使能。当某像素特征数据为 0 时，跳过对应权重的取数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_fc_con10x1064"><a class="header" href="#rknn_cna_fc_con10x1064">RKNN_cna_fc_con1（0x1064）</a></h2>
<p>全连接零跳过控制 1。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>data_offset</code></td><td style="text-align: left">FC 零跳过模式下的特征数据偏移</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_pad_con00x1068"><a class="header" href="#rknn_cna_pad_con00x1068">RKNN_cna_pad_con0（0x1068）</a></h2>
<p>Pad 控制寄存器 0。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:8</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">7:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_left</code></td><td style="text-align: left">特征图左侧 pad 数</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_top</code></td><td style="text-align: left">特征图顶部 pad 数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_feature_data_addr0x1070"><a class="header" href="#rknn_cna_feature_data_addr0x1070">RKNN_cna_feature_data_addr（0x1070）</a></h2>
<p>输入特征数据基址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>feature_base_addr</code></td><td style="text-align: left">特征数据地址</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_fc_con20x1074"><a class="header" href="#rknn_cna_fc_con20x1074">RKNN_cna_fc_con2（0x1074）</a></h2>
<p>权重数据地址偏移。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>weight_offset</code></td><td style="text-align: left">权重数据地址偏移</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_dma_con00x1078"><a class="header" href="#rknn_cna_dma_con00x1078">RKNN_cna_dma_con0（0x1078）</a></h2>
<p>AXI DMA 控制寄存器 0：burst 长度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ov4k_bypass</code></td><td style="text-align: left">超 4K burst 拆分。0：使能（将超 4K 的 burst 拆为 2 个）；1：旁路</td></tr>
<tr><td style="text-align: center">30:20</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">19:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>weight_burst_len</code></td><td style="text-align: left">权重 DMA AXI burst 长度。3：burst=4；7：burst=8；15：burst=16</td></tr>
<tr><td style="text-align: center">15:4</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>data_burst_len</code></td><td style="text-align: left">特征 DMA AXI burst 长度。编码同上</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_dma_con10x107c"><a class="header" href="#rknn_cna_dma_con10x107c">RKNN_cna_dma_con1（0x107C）</a></h2>
<p>行步长（Line stride）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:28</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">27:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>line_stride</code></td><td style="text-align: left">行步长。含虚拟框（Virtual box）的特征宽度</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_dma_con20x1080"><a class="header" href="#rknn_cna_dma_con20x1080">RKNN_cna_dma_con2（0x1080）</a></h2>
<p>Surface 步长。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:28</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">27:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>surf_stride</code></td><td style="text-align: left">Surface 步长。特征图实际 surface 面积</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_fc_data_size00x1084"><a class="header" href="#rknn_cna_fc_data_size00x1084">RKNN_cna_fc_data_size0（0x1084）</a></h2>
<p>FC 模式下 AXI DMA 的特征输入宽高。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:30</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">29:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dma_width</code></td><td style="text-align: left">AXI DMA 特征输入宽度</td></tr>
<tr><td style="text-align: center">15:11</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">10:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dma_height</code></td><td style="text-align: left">AXI DMA 特征输入高度</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_fc_data_size10x1088"><a class="header" href="#rknn_cna_fc_data_size10x1088">RKNN_cna_fc_data_size1（0x1088）</a></h2>
<p>FC 模式下 AXI DMA 的特征输入通道数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dma_channel</code></td><td style="text-align: left">AXI DMA 特征输入通道数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_clk_gate0x1090"><a class="header" href="#rknn_cna_clk_gate0x1090">RKNN_cna_clk_gate（0x1090）</a></h2>
<p>时钟门控控制寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:5</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cbuf_cs_disable_clkgate</code></td><td style="text-align: left">CBUF 自动时钟门控。0：使能自动门控；1：禁用 CBUF 时钟门控</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>csc_disable_clkgate</code></td><td style="text-align: left">CSC 自动时钟门控。0：使能；1：禁用 CSC 时钟门控</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cna_weight_disable_clkgate</code></td><td style="text-align: left">权重取数自动时钟门控。0：使能；1：禁用</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cna_feature_disable_clkgate</code></td><td style="text-align: left">特征取数自动时钟门控。0：使能；1：禁用</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_dcomp_ctrl0x1100"><a class="header" href="#rknn_cna_dcomp_ctrl0x1100">RKNN_cna_dcomp_ctrl（0x1100）</a></h2>
<p>权重解压控制寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wt_dec_bypass</code></td><td style="text-align: left">旁路权重解压</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>decomp_control</code></td><td style="text-align: left">权重解压控制</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_dcomp_regnum0x1104"><a class="header" href="#rknn_cna_dcomp_regnum0x1104">RKNN_cna_dcomp_regnum（0x1104）</a></h2>
<p>权重解压寄存器数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dcomp_regnum</code></td><td style="text-align: left">权重解压寄存器数量</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_dcomp_addr00x1110"><a class="header" href="#rknn_cna_dcomp_addr00x1110">RKNN_cna_dcomp_addr0（0x1110）</a></h2>
<p>权重基址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>decompress_addr0</code></td><td style="text-align: left">权重基址</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_dcomp_amount0150x1140--0x117c"><a class="header" href="#rknn_cna_dcomp_amount0150x1140--0x117c">RKNN_cna_dcomp_amount0~15（0x1140 ~ 0x117C）</a></h2>
<p>权重解压量寄存器，共 16 个，偏移 <code>0x1140 + N×4</code>（N = 0~15）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dcomp_amountN</code></td><td style="text-align: left">第 N 次解压的权重数据量</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_cvt_con50x1180"><a class="header" href="#rknn_cna_cvt_con50x1180">RKNN_cna_cvt_con5（0x1180）</a></h2>
<p>按通道 CVT 使能。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>per_channel_cvt_en</code></td><td style="text-align: left">按通道使能 CVT 功能。int4 共 32 通道（128 bit），int8 共 16 通道</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_cna_pad_con10x1184"><a class="header" href="#rknn_cna_pad_con10x1184">RKNN_cna_pad_con1（0x1184）</a></h2>
<p>Pad 值寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_value</code></td><td style="text-align: left">Pad 填充值</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="core-寄存器块mac-核心控制"><a class="header" href="#core-寄存器块mac-核心控制">CORE 寄存器块（MAC 核心控制）</a></h1>
<p><strong>基址</strong>：<code>CORE_BASE + 0x3000</code>　｜　<strong>地址范围</strong>：<code>0x3000 ~ 0x3FFF</code></p>
<blockquote>
<p>来源：RK3588 TRM §36.4.3 Detail Registers Description</p>
</blockquote>
<p>CORE 模块包含 MAC 阵列和累加器，负责卷积乘累加运算。</p>
<hr />
<h2 id="rknn_core_s_status0x3000"><a class="header" href="#rknn_core_s_status0x3000">RKNN_core_s_status（0x3000）</a></h2>
<p>执行器状态寄存器（只读）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:18</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">17:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_1</code></td><td style="text-align: left">执行器 1 状态。0：空闲；1：正在执行；2：正在执行且执行器 1 等待执行；3：保留</td></tr>
<tr><td style="text-align: center">15:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_0</code></td><td style="text-align: left">执行器 0 状态。编码同 <code>status_1</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_core_s_pointer0x3004"><a class="header" href="#rknn_core_s_pointer0x3004">RKNN_core_s_pointer（0x3004）</a></h2>
<p>寄存器组指针与 ping-pong 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer</code></td><td style="text-align: left">当前使用的寄存器组。0：执行器组 0；1：执行器组 1</td></tr>
<tr><td style="text-align: center">15:6</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_clear</code></td><td style="text-align: left">清除执行器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_clear</code></td><td style="text-align: left">清除寄存器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_mode</code></td><td style="text-align: left">Ping-pong 模式。0：按执行器切换；1：按指针切换</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_en</code></td><td style="text-align: left">执行器组 ping-pong 使能。0：禁用；1：使能</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_en</code></td><td style="text-align: left">寄存器组 ping-pong 使能。0：禁用；1：使能</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer</code></td><td style="text-align: left">当前待设置的寄存器组。0：组 0；1：组 1</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_core_operation_enable0x3008"><a class="header" href="#rknn_core_operation_enable0x3008">RKNN_core_operation_enable（0x3008）</a></h2>
<p>操作使能寄存器。写入此寄存器将触发 CORE 模块开始执行。此寄存器及之后的寄存器均为 ping-pong 影子寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>op_en</code></td><td style="text-align: left">CORE 操作使能。0：禁用；1：使能</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_core_mac_gating0x300c"><a class="header" href="#rknn_core_mac_gating0x300c">RKNN_core_mac_gating（0x300C）</a></h2>
<p>MAC 软时钟门控寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:27</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">26:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x7800800</td><td style="text-align: left"><code>slcg_op_en</code></td><td style="text-align: left">软时钟门控信号</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>注意</strong>：复位值为 <code>0x07800800</code>，与其他寄存器不同。</p>
</blockquote>
<hr />
<h2 id="rknn_core_misc_cfg0x3010"><a class="header" href="#rknn_core_misc_cfg0x3010">RKNN_core_misc_cfg（0x3010）</a></h2>
<p>杂项配置寄存器：精度、深度可分离、量化使能。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:20</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">19:14</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>soft_gating</code></td><td style="text-align: left">累加器软门控信号</td></tr>
<tr><td style="text-align: center">13:11</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">10:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>proc_precision</code></td><td style="text-align: left">处理精度。0：int8；1：int16；2：fp16；3：bf16；6：int4；7：tf32</td></tr>
<tr><td style="text-align: center">7:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dw_en</code></td><td style="text-align: left">深度可分离模式使能。0：禁用；1：使能 Depthwise 模式</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>qd_en</code></td><td style="text-align: left">量化特征数据计算使能。0：禁用；1：使能</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_core_dataout_size_00x3014"><a class="header" href="#rknn_core_dataout_size_00x3014">RKNN_core_dataout_size_0（0x3014）</a></h2>
<p>输出特征尺寸寄存器 0：宽高。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dataout_height</code></td><td style="text-align: left">激活后输出数据高度</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dataout_width</code></td><td style="text-align: left">激活后输出数据宽度</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_core_dataout_size_10x3018"><a class="header" href="#rknn_core_dataout_size_10x3018">RKNN_core_dataout_size_1（0x3018）</a></h2>
<p>输出特征尺寸寄存器 1：通道数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dataout_channel</code></td><td style="text-align: left">激活后输出数据通道数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_core_clip_truncate0x301c"><a class="header" href="#rknn_core_clip_truncate0x301c">RKNN_core_clip_truncate（0x301C）</a></h2>
<p>截断与舍入控制寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:7</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>round_type</code></td><td style="text-align: left">舍入类型。0：奇入偶不入；1：0.5 向上进 1</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">4:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>clip_truncate</code></td><td style="text-align: left">截断位数</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="dpu-寄存器块data-processing-unit"><a class="header" href="#dpu-寄存器块data-processing-unit">DPU 寄存器块（Data Processing Unit）</a></h1>
<p><strong>基址</strong>：<code>CORE_BASE + 0x4000</code>　｜　<strong>地址范围</strong>：<code>0x4000 ~ 0x4FFF</code></p>
<blockquote>
<p>来源：RK3588 TRM §36.4.3 Detail Registers Description</p>
</blockquote>
<p>DPU 负责后处理运算，包含三级流水线核心：BS CORE（Bias/Scale）→ BN CORE（Batch Norm）→ EW CORE（Element-Wise），以及输出转换器、LUT 引擎、转置/重组等功能。</p>
<hr />
<h2 id="rknn_dpu_s_status0x4000"><a class="header" href="#rknn_dpu_s_status0x4000">RKNN_dpu_s_status（0x4000）</a></h2>
<p>执行器状态寄存器（只读）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:18</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">17:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_1</code></td><td style="text-align: left">执行器 1 状态。0：空闲；1：正在执行；2：正在执行且等待执行；3：保留</td></tr>
<tr><td style="text-align: center">15:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_0</code></td><td style="text-align: left">执行器 0 状态。编码同 <code>status_1</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_s_pointer0x4004"><a class="header" href="#rknn_dpu_s_pointer0x4004">RKNN_dpu_s_pointer（0x4004）</a></h2>
<p>寄存器组指针与 ping-pong 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer</code></td><td style="text-align: left">当前使用的寄存器组。0：组 0；1：组 1</td></tr>
<tr><td style="text-align: center">15:6</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_clear</code></td><td style="text-align: left">清除执行器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_clear</code></td><td style="text-align: left">清除寄存器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_mode</code></td><td style="text-align: left">Ping-pong 模式。0：按执行器切换；1：按指针切换</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_en</code></td><td style="text-align: left">执行器组 ping-pong 使能</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_en</code></td><td style="text-align: left">寄存器组 ping-pong 使能</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer</code></td><td style="text-align: left">当前待设置的寄存器组。0：组 0；1：组 1</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_operation_enable0x4008"><a class="header" href="#rknn_dpu_operation_enable0x4008">RKNN_dpu_operation_enable（0x4008）</a></h2>
<p>操作使能。写入触发 DPU 执行，此寄存器及之后均为 ping-pong 影子寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>op_en</code></td><td style="text-align: left">DPU 操作使能。0：禁用；1：使能</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_feature_mode_cfg0x400c"><a class="header" href="#rknn_dpu_feature_mode_cfg0x400c">RKNN_dpu_feature_mode_cfg（0x400C）</a></h2>
<p>特征模式配置：flying mode、输出目标、卷积模式、burst、非对齐、转置、重组。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>comb_use</code></td><td style="text-align: left">组合使用，同 DPU_RDMA <code>comb_use[0]</code></td></tr>
<tr><td style="text-align: center">30</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>tp_en</code></td><td style="text-align: left">转置使能</td></tr>
<tr><td style="text-align: center">29:26</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rgp_type</code></td><td style="text-align: left">重组类型。0：全部 128bit；1：4bit；2：8bit；3：16bit；4：32bit；5：64bit</td></tr>
<tr><td style="text-align: center">25</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>nonalign</code></td><td style="text-align: left">非对齐模式使能（输出数据流与输入相同时可用）</td></tr>
<tr><td style="text-align: center">24:9</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>surf_len</code></td><td style="text-align: left">非对齐模式下存储的 8 字节数</td></tr>
<tr><td style="text-align: center">8:5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>burst_len</code></td><td style="text-align: left">Burst 长度。3：Burst4；7：Burst8；15：Burst16</td></tr>
<tr><td style="text-align: center">4:3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>conv_mode</code></td><td style="text-align: left">卷积模式。0：普通卷积；3：Depthwise</td></tr>
<tr><td style="text-align: center">2:1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>output_mode</code></td><td style="text-align: left">输出目标。[0]：输出到 PPU；[1]：输出到外部</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>flying_mode</code></td><td style="text-align: left">Flying 模式。0：主数据来自卷积输出；1：主数据来自 MRDMA</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_data_format0x4010"><a class="header" href="#rknn_dpu_data_format0x4010">RKNN_dpu_data_format（0x4010）</a></h2>
<p>数据格式配置：输入/输出/处理精度、负数移位值。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:29</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>out_precision</code></td><td style="text-align: left">输出精度。0：int8；1：int16；2：fp16；3：bf16；4：int32；5：fp32；6：int4</td></tr>
<tr><td style="text-align: center">28:26</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>in_precision</code></td><td style="text-align: left">输入精度（同 DPU_RDMA）。编码同上</td></tr>
<tr><td style="text-align: center">25:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_truncate_neg</code></td><td style="text-align: left">EW CORE 负数移位值</td></tr>
<tr><td style="text-align: center">15:10</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_mul_shift_value_neg</code></td><td style="text-align: left">BN CORE 负数移位值</td></tr>
<tr><td style="text-align: center">9:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_mul_shift_value_neg</code></td><td style="text-align: left">BS CORE 负数移位值</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>mc_surf_out</code></td><td style="text-align: left">多 surface 输出。0：每像素 16 字节对齐；1：可输出 2/4 surface 串行</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>proc_precision</code></td><td style="text-align: left">处理精度。编码同 <code>out_precision</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_offset_pend0x4014"><a class="header" href="#rknn_dpu_offset_pend0x4014">RKNN_dpu_offset_pend（0x4014）</a></h2>
<p>额外通道填充值。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>offset_pend</code></td><td style="text-align: left">额外通道设置值</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_dst_base_addr0x4020"><a class="header" href="#rknn_dpu_dst_base_addr0x4020">RKNN_dpu_dst_base_addr（0x4020）</a></h2>
<p>目标基址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dst_base_addr</code></td><td style="text-align: left">目标基址</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_dst_surf_stride0x4024"><a class="header" href="#rknn_dpu_dst_surf_stride0x4024">RKNN_dpu_dst_surf_stride（0x4024）</a></h2>
<p>输出 surface 步长。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dst_surf_stride</code></td><td style="text-align: left">输出 shape 的 surface 步长</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_data_cube_width0x4030"><a class="header" href="#rknn_dpu_data_cube_width0x4030">RKNN_dpu_data_cube_width（0x4030）</a></h2>
<p>输入 cube 宽度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>width</code></td><td style="text-align: left">输入 cube 宽度</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_data_cube_height0x4034"><a class="header" href="#rknn_dpu_data_cube_height0x4034">RKNN_dpu_data_cube_height（0x4034）</a></h2>
<p>输入 cube 高度 + minmax 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:25</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">24:22</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>minmax_ctl</code></td><td style="text-align: left">MinMax 配置。[0]：使能；[1]：类型；[2]：仅概率</td></tr>
<tr><td style="text-align: center">21:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>height</code></td><td style="text-align: left">输入 cube 高度</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_data_cube_notch_addr0x4038"><a class="header" href="#rknn_dpu_data_cube_notch_addr0x4038">RKNN_dpu_data_cube_notch_addr（0x4038）</a></h2>
<p>Notch 地址（宽度末尾到 shape 行末的像素数）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:29</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">28:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>notch_addr_1</code></td><td style="text-align: left">Notch 地址 1</td></tr>
<tr><td style="text-align: center">15:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>notch_addr_0</code></td><td style="text-align: left">Notch 地址 0</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_data_cube_channel0x403c"><a class="header" href="#rknn_dpu_data_cube_channel0x403c">RKNN_dpu_data_cube_channel（0x403C）</a></h2>
<p>输入 cube 通道数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:29</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">28:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>orig_channel</code></td><td style="text-align: left">原始输出通道数</td></tr>
<tr><td style="text-align: center">15:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>channel</code></td><td style="text-align: left">Cube 通道数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bs_cfg0x4040"><a class="header" href="#rknn_dpu_bs_cfg0x4040">RKNN_dpu_bs_cfg（0x4040）</a></h2>
<p>BS CORE 配置：ALU 算法、操作数来源、ReLU/PRELU/RELUX 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:20</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">19:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_alu_algo</code></td><td style="text-align: left">BS ALU 运算类型。2：Add；4：Minus</td></tr>
<tr><td style="text-align: center">15:9</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_alu_src</code></td><td style="text-align: left">ALU 操作数来源。0：寄存器；1：外部</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_relux_en</code></td><td style="text-align: left">RELUX 使能</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_relu_bypass</code></td><td style="text-align: left">旁路 BS RELU。0：不旁路；1：旁路</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_mul_prelu</code></td><td style="text-align: left">MUL PRELU 使能</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_mul_bypass</code></td><td style="text-align: left">旁路 BS MUL</td></tr>
<tr><td style="text-align: center">3:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_alu_bypass</code></td><td style="text-align: left">旁路 BS ALU</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_bypass</code></td><td style="text-align: left">旁路整个 BS CORE</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bs_alu_cfg0x4044"><a class="header" href="#rknn_dpu_bs_alu_cfg0x4044">RKNN_dpu_bs_alu_cfg（0x4044）</a></h2>
<p>BS ALU 操作数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_alu_operand</code></td><td style="text-align: left">BS CORE ALU 操作数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bs_mul_cfg0x4048"><a class="header" href="#rknn_dpu_bs_mul_cfg0x4048">RKNN_dpu_bs_mul_cfg（0x4048）</a></h2>
<p>BS MUL 配置：操作数、移位值、来源。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_mul_operand</code></td><td style="text-align: left">BS MUL 操作数</td></tr>
<tr><td style="text-align: center">15:14</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">13:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_mul_shift_value</code></td><td style="text-align: left">BS 正数移位值</td></tr>
<tr><td style="text-align: center">7:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_truncate_src</code></td><td style="text-align: left">移位值来源。0：寄存器；1：外部</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_mul_src</code></td><td style="text-align: left">MUL 操作数来源。0：寄存器；1：外部</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bs_relux_cmp_value0x404c"><a class="header" href="#rknn_dpu_bs_relux_cmp_value0x404c">RKNN_dpu_bs_relux_cmp_value（0x404C）</a></h2>
<p>BS RELUX 比较值。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_relux_cmp_dat</code></td><td style="text-align: left">RELUX 比较值</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bs_ow_cfg0x4050"><a class="header" href="#rknn_dpu_bs_ow_cfg0x4050">RKNN_dpu_bs_ow_cfg（0x4050）</a></h2>
<p>BS OW（CPEND）配置 + 重组计数器 + 转置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:28</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rgp_cnter</code></td><td style="text-align: left">重组计数器。0：全选；1：每 2 选 1；2：每 4 选 1；3：每 8 选 1</td></tr>
<tr><td style="text-align: center">27</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>tp_org_en</code></td><td style="text-align: left">原始转置使能</td></tr>
<tr><td style="text-align: center">26:11</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">10:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>size_e_2</code></td><td style="text-align: left">最后一行输出每行 8 通道数（−1）</td></tr>
<tr><td style="text-align: center">7:5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>size_e_1</code></td><td style="text-align: left">中间行输出每行 8 通道数（−1）</td></tr>
<tr><td style="text-align: center">4:2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>size_e_0</code></td><td style="text-align: left">第一行输出每行 8 通道数（−1）</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>od_bypass</code></td><td style="text-align: left">旁路 CPEND</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ow_src</code></td><td style="text-align: left">CPEND 操作数来源。0：寄存器；1：外部</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bs_ow_op0x4054"><a class="header" href="#rknn_dpu_bs_ow_op0x4054">RKNN_dpu_bs_ow_op（0x4054）</a></h2>
<p>CPEND 操作数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ow_op</code></td><td style="text-align: left">CPEND 操作数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_wdma_size_00x4058"><a class="header" href="#rknn_dpu_wdma_size_00x4058">RKNN_dpu_wdma_size_0（0x4058）</a></h2>
<p>DPU WDMA 尺寸 0：转置精度、通道。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:28</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">27</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>tp_precision</code></td><td style="text-align: left">转置精度。0：8bit；1：16bit</td></tr>
<tr><td style="text-align: center">26:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>size_c_wdma</code></td><td style="text-align: left">WDMA 的 size_c</td></tr>
<tr><td style="text-align: center">15:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>channel_wdma</code></td><td style="text-align: left">WDMA 通道数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_wdma_size_10x405c"><a class="header" href="#rknn_dpu_wdma_size_10x405c">RKNN_dpu_wdma_size_1（0x405C）</a></h2>
<p>DPU WDMA 尺寸 1：宽高。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:29</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">28:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>height_wdma</code></td><td style="text-align: left">WDMA 高度</td></tr>
<tr><td style="text-align: center">15:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>width_wdma</code></td><td style="text-align: left">WDMA 宽度</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bn_cfg0x4060"><a class="header" href="#rknn_dpu_bn_cfg0x4060">RKNN_dpu_bn_cfg（0x4060）</a></h2>
<p>BN CORE 配置：ALU 算法、操作数来源、ReLU/PRELU/RELUX 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:20</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">19:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_alu_algo</code></td><td style="text-align: left">BN ALU 运算类型。2：Add；4：Minus</td></tr>
<tr><td style="text-align: center">15:9</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_alu_src</code></td><td style="text-align: left">ALU 操作数来源。0：寄存器；1：外部</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_relux_en</code></td><td style="text-align: left">RELUX 使能</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_relu_bypass</code></td><td style="text-align: left">旁路 BN RELU</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_mul_prelu</code></td><td style="text-align: left">MUL PRELU 使能</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_mul_bypass</code></td><td style="text-align: left">旁路 BN MUL</td></tr>
<tr><td style="text-align: center">3:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_alu_bypass</code></td><td style="text-align: left">旁路 BN ALU</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_bypass</code></td><td style="text-align: left">旁路整个 BN CORE</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bn_alu_cfg0x4064"><a class="header" href="#rknn_dpu_bn_alu_cfg0x4064">RKNN_dpu_bn_alu_cfg（0x4064）</a></h2>
<p>BN ALU 操作数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_alu_operand</code></td><td style="text-align: left">BN CORE ALU 操作数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bn_mul_cfg0x4068"><a class="header" href="#rknn_dpu_bn_mul_cfg0x4068">RKNN_dpu_bn_mul_cfg（0x4068）</a></h2>
<p>BN MUL 配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_mul_operand</code></td><td style="text-align: left">BN MUL 操作数</td></tr>
<tr><td style="text-align: center">15:14</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">13:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_mul_shift_value</code></td><td style="text-align: left">BN 正数移位值</td></tr>
<tr><td style="text-align: center">7:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_truncate_src</code></td><td style="text-align: left">移位值来源。0：寄存器；1：外部</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_mul_src</code></td><td style="text-align: left">MUL 操作数来源。0：寄存器；1：外部</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_bn_relux_cmp_value0x406c"><a class="header" href="#rknn_dpu_bn_relux_cmp_value0x406c">RKNN_dpu_bn_relux_cmp_value（0x406C）</a></h2>
<p>BN RELUX 比较值。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_relux_cmp_dat</code></td><td style="text-align: left">BN RELUX 比较数据</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_ew_cfg0x4070"><a class="header" href="#rknn_dpu_ew_cfg0x4070">RKNN_dpu_ew_cfg（0x4070）</a></h2>
<p>EW CORE 配置：ALU 算法（Max/Min/Add/Div/Minus/Abs/Neg/Floor/Ceil）、LUT、转换器、PRELU 等。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_cvt_type</code></td><td style="text-align: left">EW 输入转换类型。0：先乘后加；1：先加后乘</td></tr>
<tr><td style="text-align: center">30</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_cvt_round</code></td><td style="text-align: left">EW 输入转换舍入。0：奇入偶不入；1：0.5 向上进 1</td></tr>
<tr><td style="text-align: center">29:28</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_data_mode</code></td><td style="text-align: left">ERDMA 数据模式</td></tr>
<tr><td style="text-align: center">27:24</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">23:22</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>edata_size</code></td><td style="text-align: left">ERDMA cube 数据大小。0：4bit；1：8bit；2：16bit；3：32bit</td></tr>
<tr><td style="text-align: center">21</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_equal_en</code></td><td style="text-align: left">MinMax 相等使能</td></tr>
<tr><td style="text-align: center">20</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_binary_en</code></td><td style="text-align: left">MinMax 二值使能</td></tr>
<tr><td style="text-align: center">19:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_alu_algo</code></td><td style="text-align: left">EW ALU 运算。0：Max；1：Min；2：Add；3：Div；4：Minus；5：Abs；6：Neg；7：Floor；8：Ceil</td></tr>
<tr><td style="text-align: center">15:11</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">10</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_relux_en</code></td><td style="text-align: left">RELUX 使能</td></tr>
<tr><td style="text-align: center">9</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_relu_bypass</code></td><td style="text-align: left">旁路 EW RELU</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_op_cvt_bypass</code></td><td style="text-align: left">旁路 EW 输入转换器</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_lut_bypass</code></td><td style="text-align: left">旁路 LUT</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_op_src</code></td><td style="text-align: left">操作数来源。0：寄存器；1：外部</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_mul_prelu</code></td><td style="text-align: left">MUL PRELU 使能</td></tr>
<tr><td style="text-align: center">4:3</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_op_type</code></td><td style="text-align: left">运算类型。0：ALU；1：MUL</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_op_bypass</code></td><td style="text-align: left">旁路 EW ALU 和 MUL</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_bypass</code></td><td style="text-align: left">旁路整个 EW CORE</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_ew_cvt_offset_value0x4074"><a class="header" href="#rknn_dpu_ew_cvt_offset_value0x4074">RKNN_dpu_ew_cvt_offset_value（0x4074）</a></h2>
<p>EW 输入转换偏移。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_op_cvt_offset</code></td><td style="text-align: left">EW 转换偏移</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_ew_cvt_scale_value0x4078"><a class="header" href="#rknn_dpu_ew_cvt_scale_value0x4078">RKNN_dpu_ew_cvt_scale_value（0x4078）</a></h2>
<p>EW 转换缩放与移位。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:22</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_truncate</code></td><td style="text-align: left">EW CORE 移位值</td></tr>
<tr><td style="text-align: center">21:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_op_cvt_shift</code></td><td style="text-align: left">EW 转换移位值</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_op_cvt_scale</code></td><td style="text-align: left">EW 转换缩放</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_ew_relux_cmp_value0x407c"><a class="header" href="#rknn_dpu_ew_relux_cmp_value0x407c">RKNN_dpu_ew_relux_cmp_value（0x407C）</a></h2>
<p>EW RELUX 比较值。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_relux_cmp_dat</code></td><td style="text-align: left">EW RELUX 比较数据</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_out_cvt_offset0x4080"><a class="header" href="#rknn_dpu_out_cvt_offset0x4080">RKNN_dpu_out_cvt_offset（0x4080）</a></h2>
<p>输出转换偏移。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>out_cvt_offset</code></td><td style="text-align: left">输出转换器偏移</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_out_cvt_scale0x4084"><a class="header" href="#rknn_dpu_out_cvt_scale0x4084">RKNN_dpu_out_cvt_scale（0x4084）</a></h2>
<p>输出转换缩放 + fp32→fp16 使能。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>fp32tofp16_en</code></td><td style="text-align: left">使能输出 fp32→fp16 转换</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>out_cvt_scale</code></td><td style="text-align: left">输出转换器缩放</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_out_cvt_shift0x4088"><a class="header" href="#rknn_dpu_out_cvt_shift0x4088">RKNN_dpu_out_cvt_shift（0x4088）</a></h2>
<p>输出转换移位、舍入、指数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_type</code></td><td style="text-align: left">输出转换类型。0：先乘后加；1：先加后乘</td></tr>
<tr><td style="text-align: center">30</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cvt_round</code></td><td style="text-align: left">输出转换舍入。0：奇入偶不入；1：0.5 向上进 1</td></tr>
<tr><td style="text-align: center">29:20</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">19:12</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>minus_exp</code></td><td style="text-align: left">输出 CVT 减指数</td></tr>
<tr><td style="text-align: center">11:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>out_cvt_shift</code></td><td style="text-align: left">输出转换器移位</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_ew_op_value_070x4090--0x40ac"><a class="header" href="#rknn_dpu_ew_op_value_070x4090--0x40ac">RKNN_dpu_ew_op_value_0~7（0x4090 ~ 0x40AC）</a></h2>
<p>EW CORE 操作数寄存器，共 8 个，偏移 <code>0x4090 + N×4</code>（N = 0~7）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_operand_N</code></td><td style="text-align: left">第 N+1 个 EW 操作数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_surface_add0x40c0"><a class="header" href="#rknn_dpu_surface_add0x40c0">RKNN_dpu_surface_add（0x40C0）</a></h2>
<p>Surface 加法器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>surf_add</code></td><td style="text-align: left">一行中有多少个 surface</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_access_cfg0x4100"><a class="header" href="#rknn_dpu_lut_access_cfg0x4100">RKNN_dpu_lut_access_cfg（0x4100）</a></h2>
<p>LUT 访问配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:18</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">17</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_access_type</code></td><td style="text-align: left">访问类型。0：读；1：写</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_table_id</code></td><td style="text-align: left">访问 ID。0：LE LUT；1：LO LUT</td></tr>
<tr><td style="text-align: center">15:10</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">9:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_addr</code></td><td style="text-align: left">访问地址</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_access_data0x4104"><a class="header" href="#rknn_dpu_lut_access_data0x4104">RKNN_dpu_lut_access_data（0x4104）</a></h2>
<p>LUT 访问数据。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_access_data</code></td><td style="text-align: left">LUT 访问数据</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_cfg0x4108"><a class="header" href="#rknn_dpu_lut_cfg0x4108">RKNN_dpu_lut_cfg（0x4108）</a></h2>
<p>LUT 配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:8</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_cal_sel</code></td><td style="text-align: left">LUT 计算选择（仅 <code>lut_expand_en=1</code> 时有效）</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_hybrid_priority</code></td><td style="text-align: left">混合流优先级。0：LE LUT；1：LO LUT</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_oflow_priority</code></td><td style="text-align: left">上溢优先级。0：LE；1：LO</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_uflow_priority</code></td><td style="text-align: left">下溢优先级。0：LE；1：LO</td></tr>
<tr><td style="text-align: center">3:2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_lo_le_mux</code></td><td style="text-align: left">LO/LE LUT 复用</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_expand_en</code></td><td style="text-align: left">扩展两个小 LUT 为一个大 LUT</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_road_sel</code></td><td style="text-align: left">LUT 路径选择。0：第 1 路；1：第 2 路</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_info0x410c"><a class="header" href="#rknn_dpu_lut_info0x410c">RKNN_dpu_lut_info（0x410C）</a></h2>
<p>LUT 索引选择。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:24</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">23:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_lo_index_select</code></td><td style="text-align: left">LO LUT 索引选择（索引生成器中选择哪些位作为索引）</td></tr>
<tr><td style="text-align: center">15:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_le_index_select</code></td><td style="text-align: left">LE LUT 索引选择</td></tr>
<tr><td style="text-align: center">7:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_le_start0x4110"><a class="header" href="#rknn_dpu_lut_le_start0x4110">RKNN_dpu_lut_le_start（0x4110）</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_le_start</code></td><td style="text-align: left">LE LUT 起始点</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_le_end0x4114"><a class="header" href="#rknn_dpu_lut_le_end0x4114">RKNN_dpu_lut_le_end（0x4114）</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_le_end</code></td><td style="text-align: left">LE LUT 终止点</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_lo_start0x4118"><a class="header" href="#rknn_dpu_lut_lo_start0x4118">RKNN_dpu_lut_lo_start（0x4118）</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_lo_start</code></td><td style="text-align: left">LO LUT 起始点</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_lo_end0x411c"><a class="header" href="#rknn_dpu_lut_lo_end0x411c">RKNN_dpu_lut_lo_end（0x411C）</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_lo_end</code></td><td style="text-align: left">LO LUT 终止点</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_le_slope_scale0x4120"><a class="header" href="#rknn_dpu_lut_le_slope_scale0x4120">RKNN_dpu_lut_le_slope_scale（0x4120）</a></h2>
<p>LE LUT 斜率缩放（上溢/下溢）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_le_slope_oflow_scale</code></td><td style="text-align: left">LE LUT 上溢斜率缩放</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_le_slope_uflow_scale</code></td><td style="text-align: left">LE LUT 下溢斜率缩放</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_le_slope_shift0x4124"><a class="header" href="#rknn_dpu_lut_le_slope_shift0x4124">RKNN_dpu_lut_le_slope_shift（0x4124）</a></h2>
<p>LE LUT 斜率移位。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:10</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">9:5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_le_slope_oflow_shift</code></td><td style="text-align: left">LE LUT 上溢斜率移位</td></tr>
<tr><td style="text-align: center">4:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_le_slope_uflow_shift</code></td><td style="text-align: left">LE LUT 下溢斜率移位</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_lo_slope_scale0x4128"><a class="header" href="#rknn_dpu_lut_lo_slope_scale0x4128">RKNN_dpu_lut_lo_slope_scale（0x4128）</a></h2>
<p>LO LUT 斜率缩放。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_lo_slope_oflow_scale</code></td><td style="text-align: left">LO LUT 上溢斜率缩放</td></tr>
<tr><td style="text-align: center">15:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_lo_slope_uflow_scale</code></td><td style="text-align: left">LO LUT 下溢斜率缩放</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_lut_lo_slope_shift0x412c"><a class="header" href="#rknn_dpu_lut_lo_slope_shift0x412c">RKNN_dpu_lut_lo_slope_shift（0x412C）</a></h2>
<p>LO LUT 斜率移位。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:10</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">9:5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_lo_slope_oflow_shift</code></td><td style="text-align: left">LO LUT 上溢斜率移位</td></tr>
<tr><td style="text-align: center">4:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>lut_lo_slope_uflow_shift</code></td><td style="text-align: left">LO LUT 下溢斜率移位</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="dpu_rdma-寄存器块"><a class="header" href="#dpu_rdma-寄存器块">DPU_RDMA 寄存器块</a></h1>
<p><strong>基址</strong>：<code>CORE_BASE + 0x5000</code>　｜　<strong>地址范围</strong>：<code>0x5000 ~ 0x5FFF</code></p>
<blockquote>
<p>来源：RK3588 TRM §36.4.3 Detail Registers Description</p>
</blockquote>
<p>DPU_RDMA 负责为 DPU 从外部内存读取输入数据，包含四路 DMA 引擎：MRDMA（主数据）、BRDMA（BS 操作数）、NRDMA（BN 操作数）、ERDMA（EW 操作数）。</p>
<hr />
<h2 id="rknn_dpu_rdma_s_status0x5000"><a class="header" href="#rknn_dpu_rdma_s_status0x5000">RKNN_dpu_rdma_s_status（0x5000）</a></h2>
<p>执行器状态寄存器（只读）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:18</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">17:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_1</code></td><td style="text-align: left">执行器 1 状态。0：空闲；1：正在执行；2：正在执行且等待执行；3：保留</td></tr>
<tr><td style="text-align: center">15:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_0</code></td><td style="text-align: left">执行器 0 状态。编码同 <code>status_1</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_s_pointer0x5004"><a class="header" href="#rknn_dpu_rdma_s_pointer0x5004">RKNN_dpu_rdma_s_pointer（0x5004）</a></h2>
<p>寄存器组指针与 ping-pong 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer</code></td><td style="text-align: left">当前使用的寄存器组。0：组 0；1：组 1</td></tr>
<tr><td style="text-align: center">15:6</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_clear</code></td><td style="text-align: left">清除执行器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_clear</code></td><td style="text-align: left">清除寄存器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_mode</code></td><td style="text-align: left">Ping-pong 模式。0：按执行器切换；1：按指针切换</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_en</code></td><td style="text-align: left">执行器组 ping-pong 使能</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_en</code></td><td style="text-align: left">寄存器组 ping-pong 使能</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer</code></td><td style="text-align: left">当前待设置的寄存器组。0：组 0；1：组 1</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_operation_enable0x5008"><a class="header" href="#rknn_dpu_rdma_operation_enable0x5008">RKNN_dpu_rdma_operation_enable（0x5008）</a></h2>
<p>操作使能。写入触发 DPU_RDMA 执行，此寄存器及之后均为 ping-pong 影子寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>op_en</code></td><td style="text-align: left">DPU_RDMA 操作使能。0：禁用；1：使能</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_data_cube_width0x500c"><a class="header" href="#rknn_dpu_rdma_data_cube_width0x500c">RKNN_dpu_rdma_data_cube_width（0x500C）</a></h2>
<p>输入特征宽度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>width</code></td><td style="text-align: left">输入特征宽度（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_data_cube_height0x5010"><a class="header" href="#rknn_dpu_rdma_data_cube_height0x5010">RKNN_dpu_rdma_data_cube_height（0x5010）</a></h2>
<p>输入特征高度 + EW line notch。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:29</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">28:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_line_notch_addr</code></td><td style="text-align: left">EW 行 notch</td></tr>
<tr><td style="text-align: center">15:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>height</code></td><td style="text-align: left">输入特征高度（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_data_cube_channel0x5014"><a class="header" href="#rknn_dpu_rdma_data_cube_channel0x5014">RKNN_dpu_rdma_data_cube_channel（0x5014）</a></h2>
<p>输入特征通道数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>channel</code></td><td style="text-align: left">输入特征通道数（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_src_base_addr0x5018"><a class="header" href="#rknn_dpu_rdma_src_base_addr0x5018">RKNN_dpu_rdma_src_base_addr（0x5018）</a></h2>
<p>Flying 模式源地址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>src_base_addr</code></td><td style="text-align: left">Flying 模式源地址</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_brdma_cfg0x501c"><a class="header" href="#rknn_dpu_rdma_brdma_cfg0x501c">RKNN_dpu_rdma_brdma_cfg（0x501C）</a></h2>
<p>BRDMA（BS 操作数读取 DMA）配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:5</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">4:1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>brdma_data_use</code></td><td style="text-align: left">读取数据类型。[0]：ALU 操作数；[1]：CPEND 操作数；[2]：MUL 操作数；[3]：TRT 操作数</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_bs_base_addr0x5020"><a class="header" href="#rknn_dpu_rdma_bs_base_addr0x5020">RKNN_dpu_rdma_bs_base_addr（0x5020）</a></h2>
<p>BS 操作数基址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bs_base_addr</code></td><td style="text-align: left">读取 BS ALU、BS CPEND、BS MUL 操作数的基址</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_nrdma_cfg0x5028"><a class="header" href="#rknn_dpu_rdma_nrdma_cfg0x5028">RKNN_dpu_rdma_nrdma_cfg（0x5028）</a></h2>
<p>NRDMA（BN 操作数读取 DMA）配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:5</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">4:1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>nrdma_data_use</code></td><td style="text-align: left">读取数据类型。[0]：ALU 操作数；[1]：CPEND 操作数（固定为 0，BN 无 CPEND）；[2]：MUL 操作数；[3]：TRT 操作数</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_bn_base_addr0x502c"><a class="header" href="#rknn_dpu_rdma_bn_base_addr0x502c">RKNN_dpu_rdma_bn_base_addr（0x502C）</a></h2>
<p>BN 操作数基址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>bn_base_addr</code></td><td style="text-align: left">读取 BN ALU、BN MUL 操作数的基址</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_erdma_cfg0x5034"><a class="header" href="#rknn_dpu_rdma_erdma_cfg0x5034">RKNN_dpu_rdma_erdma_cfg（0x5034）</a></h2>
<p>ERDMA（EW 操作数读取 DMA）配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:30</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>erdma_data_mode</code></td><td style="text-align: left">数据模式。0：按通道；1：按像素；2：按通道×像素；3：保留</td></tr>
<tr><td style="text-align: center">29</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>erdma_surf_mode</code></td><td style="text-align: left">Surface 模式。0：1 surface 串行；1：2 surface 串行</td></tr>
<tr><td style="text-align: center">28</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>erdma_nonalign</code></td><td style="text-align: left">非对齐模式。0：禁用；1：使能</td></tr>
<tr><td style="text-align: center">27:4</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">3:2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>erdma_data_size</code></td><td style="text-align: left">ERDMA 读取精度。0：4bit；1：8bit；2：16bit；3：32bit</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ov4k_bypass</code></td><td style="text-align: left">超 4K burst 拆分。0：使能；1：旁路</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>erdma_disable</code></td><td style="text-align: left">禁用 ERDMA。0：不禁用；1：禁用</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_ew_base_addr0x5038"><a class="header" href="#rknn_dpu_rdma_ew_base_addr0x5038">RKNN_dpu_rdma_ew_base_addr（0x5038）</a></h2>
<p>EW 操作数基址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_base_addr</code></td><td style="text-align: left">读取 EW 操作数的基址</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_ew_surf_stride0x5040"><a class="header" href="#rknn_dpu_rdma_ew_surf_stride0x5040">RKNN_dpu_rdma_ew_surf_stride（0x5040）</a></h2>
<p>EW 特征图 surface 步长。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_surf_stride</code></td><td style="text-align: left">EW 特征图 surface 步长。若 <code>erdma_data_mode</code> 为按通道模式，需设为 1</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_feature_mode_cfg0x5044"><a class="header" href="#rknn_dpu_rdma_feature_mode_cfg0x5044">RKNN_dpu_rdma_feature_mode_cfg（0x5044）</a></h2>
<p>特征模式配置：精度、burst、组合使用、flying mode、unpooling。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:18</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">17:15</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>in_precision</code></td><td style="text-align: left">输入数据精度。0：int8；1：int16；2：fp16；3：bf16；4：int32；5：fp32；6：int4</td></tr>
<tr><td style="text-align: center">14:11</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>burst_len</code></td><td style="text-align: left">Burst 长度。3：Burst4；7：Burst8；15：Burst16</td></tr>
<tr><td style="text-align: center">10:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>comb_use</code></td><td style="text-align: left">组合使用。[0]：MRDMA 和 ERDMA 读同一数据；[1]：数据送 MRDMA；[2]：数据送 ERDMA</td></tr>
<tr><td style="text-align: center">7:5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>proc_precision</code></td><td style="text-align: left">处理精度。编码同 <code>in_precision</code></td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>mrdma_disable</code></td><td style="text-align: left">禁用 MRDMA。0：不禁用；1：禁用</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>mrdma_fp16tofp32_en</code></td><td style="text-align: left">使能 DPU 输入 fp16→fp32 转换</td></tr>
<tr><td style="text-align: center">2:1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>conv_mode</code></td><td style="text-align: left">卷积模式。0：DC；3：Depthwise</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>flying_mode</code></td><td style="text-align: left">Flying 模式。0：主数据来自卷积输出；1：主数据来自 MRDMA</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_src_dma_cfg0x5048"><a class="header" href="#rknn_dpu_rdma_src_dma_cfg0x5048">RKNN_dpu_rdma_src_dma_cfg（0x5048）</a></h2>
<p>源 DMA 配置：line notch、unpooling 参数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:19</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>line_notch_addr</code></td><td style="text-align: left">宽度末尾到 shape 特征行末的像素数</td></tr>
<tr><td style="text-align: center">18:14</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">13</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pooling_method</code></td><td style="text-align: left">池化方法。0：平均池化（上采样可用此模式）；1：最小/最大池化</td></tr>
<tr><td style="text-align: center">12</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>unpooling_en</code></td><td style="text-align: left">反池化使能</td></tr>
<tr><td style="text-align: center">11:9</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>kernel_stride_height</code></td><td style="text-align: left">反池化 kernel 步长高度（−1）</td></tr>
<tr><td style="text-align: center">8:6</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>kernel_stride_width</code></td><td style="text-align: left">反池化 kernel 步长宽度（−1）</td></tr>
<tr><td style="text-align: center">5:3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>kernel_height</code></td><td style="text-align: left">反池化 kernel 高度（−1）</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>kernel_width</code></td><td style="text-align: left">反池化 kernel 宽度（−1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_surf_notch0x504c"><a class="header" href="#rknn_dpu_rdma_surf_notch0x504c">RKNN_dpu_rdma_surf_notch（0x504C）</a></h2>
<p>Surface notch。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>surf_notch_addr</code></td><td style="text-align: left">当前处理特征图末尾到 shape 特征图末尾的像素数</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_pad_cfg0x5064"><a class="header" href="#rknn_dpu_rdma_pad_cfg0x5064">RKNN_dpu_rdma_pad_cfg（0x5064）</a></h2>
<p>反池化 Pad 配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_value</code></td><td style="text-align: left">Pad 填充值</td></tr>
<tr><td style="text-align: center">15:7</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">6:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_top</code></td><td style="text-align: left">反池化顶部 pad</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_left</code></td><td style="text-align: left">反池化左侧 pad</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_weight0x5068"><a class="header" href="#rknn_dpu_rdma_weight0x5068">RKNN_dpu_rdma_weight（0x5068）</a></h2>
<p>四路 DMA 仲裁权重。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:24</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>e_weight</code></td><td style="text-align: left">ERDMA 仲裁权重</td></tr>
<tr><td style="text-align: center">23:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>n_weight</code></td><td style="text-align: left">NRDMA 仲裁权重</td></tr>
<tr><td style="text-align: center">15:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>b_weight</code></td><td style="text-align: left">BRDMA 仲裁权重</td></tr>
<tr><td style="text-align: center">7:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>m_weight</code></td><td style="text-align: left">MRDMA 仲裁权重</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_dpu_rdma_ew_surf_notch0x506c"><a class="header" href="#rknn_dpu_rdma_ew_surf_notch0x506c">RKNN_dpu_rdma_ew_surf_notch（0x506C）</a></h2>
<p>EW surface notch。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ew_surf_notch</code></td><td style="text-align: left">EW surface notch</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ppu-寄存器块planar-processing-unit"><a class="header" href="#ppu-寄存器块planar-processing-unit">PPU 寄存器块（Planar Processing Unit）</a></h1>
<p><strong>基址</strong>：<code>CORE_BASE + 0x6000</code>　｜　<strong>地址范围</strong>：<code>0x6000 ~ 0x6FFF</code></p>
<blockquote>
<p>来源：RK3588 TRM §36.4.3 Detail Registers Description</p>
</blockquote>
<p>PPU 负责池化运算，支持平均池化、最大池化、最小池化，可与 DPU 流水线级联或独立 flying 模式运行。</p>
<hr />
<h2 id="rknn_ppu_s_status0x6000"><a class="header" href="#rknn_ppu_s_status0x6000">RKNN_ppu_s_status（0x6000）</a></h2>
<p>执行器状态寄存器（只读）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:18</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">17:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_1</code></td><td style="text-align: left">执行器 1 状态。0：空闲；1：正在执行；2：正在执行且等待执行；3：保留</td></tr>
<tr><td style="text-align: center">15:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_0</code></td><td style="text-align: left">执行器 0 状态。编码同 <code>status_1</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_s_pointer0x6004"><a class="header" href="#rknn_ppu_s_pointer0x6004">RKNN_ppu_s_pointer（0x6004）</a></h2>
<p>寄存器组指针与 ping-pong 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer</code></td><td style="text-align: left">当前使用的寄存器组。0：组 0；1：组 1</td></tr>
<tr><td style="text-align: center">15:6</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_clear</code></td><td style="text-align: left">清除执行器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_clear</code></td><td style="text-align: left">清除寄存器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_mode</code></td><td style="text-align: left">Ping-pong 模式。0：按执行器切换；1：按指针切换</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_en</code></td><td style="text-align: left">执行器组 ping-pong 使能</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_en</code></td><td style="text-align: left">寄存器组 ping-pong 使能</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer</code></td><td style="text-align: left">当前待设置的寄存器组。0：组 0；1：组 1</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_operation_enable0x6008"><a class="header" href="#rknn_ppu_operation_enable0x6008">RKNN_ppu_operation_enable（0x6008）</a></h2>
<p>操作使能。写入触发 PPU 执行，此寄存器及之后均为 ping-pong 影子寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>op_en</code></td><td style="text-align: left">PPU 操作使能。0：禁用；1：使能</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_data_cube_in_width0x600c"><a class="header" href="#rknn_ppu_data_cube_in_width0x600c">RKNN_ppu_data_cube_in_width（0x600C）</a></h2>
<p>池化输入 cube 宽度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cube_in_width</code></td><td style="text-align: left">池化输入宽度（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_data_cube_in_height0x6010"><a class="header" href="#rknn_ppu_data_cube_in_height0x6010">RKNN_ppu_data_cube_in_height（0x6010）</a></h2>
<p>池化输入 cube 高度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cube_in_height</code></td><td style="text-align: left">池化输入高度（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_data_cube_in_channel0x6014"><a class="header" href="#rknn_ppu_data_cube_in_channel0x6014">RKNN_ppu_data_cube_in_channel（0x6014）</a></h2>
<p>池化输入 cube 通道数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cube_in_channel</code></td><td style="text-align: left">池化输入通道数（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_data_cube_out_width0x6018"><a class="header" href="#rknn_ppu_data_cube_out_width0x6018">RKNN_ppu_data_cube_out_width（0x6018）</a></h2>
<p>池化输出 cube 宽度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cube_out_width</code></td><td style="text-align: left">池化输出宽度（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_data_cube_out_height0x601c"><a class="header" href="#rknn_ppu_data_cube_out_height0x601c">RKNN_ppu_data_cube_out_height（0x601C）</a></h2>
<p>池化输出 cube 高度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cube_out_height</code></td><td style="text-align: left">池化输出高度（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_data_cube_out_channel0x6020"><a class="header" href="#rknn_ppu_data_cube_out_channel0x6020">RKNN_ppu_data_cube_out_channel（0x6020）</a></h2>
<p>池化输出 cube 通道数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cube_out_channel</code></td><td style="text-align: left">池化输出通道数（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_operation_mode_cfg0x6024"><a class="header" href="#rknn_ppu_operation_mode_cfg0x6024">RKNN_ppu_operation_mode_cfg（0x6024）</a></h2>
<p>操作模式配置：池化方法、flying mode、notch、索引输出。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">30</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>index_en</code></td><td style="text-align: left">使能输出每个 kernel 的位置索引</td></tr>
<tr><td style="text-align: center">29</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">28:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>notch_addr</code></td><td style="text-align: left">宽度末尾到 shape 行末的像素数</td></tr>
<tr><td style="text-align: center">15:8</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">7:5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>use_cnt</code></td><td style="text-align: left">use_cnt</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>flying_mode</code></td><td style="text-align: left">池化 cube 来源。0：DPU；1：外部</td></tr>
<tr><td style="text-align: center">3:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pooling_method</code></td><td style="text-align: left">池化方法。0：平均池化；1：最大池化；2：最小池化；3：保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_pooling_kernel_cfg0x6034"><a class="header" href="#rknn_ppu_pooling_kernel_cfg0x6034">RKNN_ppu_pooling_kernel_cfg（0x6034）</a></h2>
<p>池化 kernel 大小与步长。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:24</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">23:20</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>kernel_stride_height</code></td><td style="text-align: left">Kernel 步长高度（需减 1）</td></tr>
<tr><td style="text-align: center">19:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>kernel_stride_width</code></td><td style="text-align: left">Kernel 步长宽度（需减 1）</td></tr>
<tr><td style="text-align: center">15:12</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">11:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>kernel_height</code></td><td style="text-align: left">Kernel 高度（需减 1）</td></tr>
<tr><td style="text-align: center">7:4</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>kernel_width</code></td><td style="text-align: left">Kernel 宽度（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_recip_kernel_width0x6038"><a class="header" href="#rknn_ppu_recip_kernel_width0x6038">RKNN_ppu_recip_kernel_width（0x6038）</a></h2>
<p>Kernel 宽度倒数（用于平均池化计算）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>recip_kernel_width</code></td><td style="text-align: left">Shape kernel 宽度的倒数 × 2^16</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_recip_kernel_height0x603c"><a class="header" href="#rknn_ppu_recip_kernel_height0x603c">RKNN_ppu_recip_kernel_height（0x603C）</a></h2>
<p>Kernel 高度倒数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>recip_kernel_height</code></td><td style="text-align: left">Shape kernel 高度的倒数 × 2^16</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_pooling_padding_cfg0x6040"><a class="header" href="#rknn_ppu_pooling_padding_cfg0x6040">RKNN_ppu_pooling_padding_cfg（0x6040）</a></h2>
<p>池化四边 padding。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:15</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">14:12</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_bottom</code></td><td style="text-align: left">底部 pad</td></tr>
<tr><td style="text-align: center">11</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">10:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_right</code></td><td style="text-align: left">右侧 pad</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">6:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_top</code></td><td style="text-align: left">顶部 pad</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_left</code></td><td style="text-align: left">左侧 pad</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_padding_value_1_cfg0x6044"><a class="header" href="#rknn_ppu_padding_value_1_cfg0x6044">RKNN_ppu_padding_value_1_cfg（0x6044）</a></h2>
<p>Pad 填充值低 32 位。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_value_0</code></td><td style="text-align: left">pad_value×1 [31:0]</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_padding_value_2_cfg0x6048"><a class="header" href="#rknn_ppu_padding_value_2_cfg0x6048">RKNN_ppu_padding_value_2_cfg（0x6048）</a></h2>
<p>Pad 填充值高 3 位。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:3</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pad_value_1</code></td><td style="text-align: left">pad_value×1 [34:32]</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_dst_base_addr0x6070"><a class="header" href="#rknn_ppu_dst_base_addr0x6070">RKNN_ppu_dst_base_addr（0x6070）</a></h2>
<p>输出 cube 目标基址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dst_base_addr</code></td><td style="text-align: left">输出 cube 目标基址</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_dst_surf_stride0x607c"><a class="header" href="#rknn_ppu_dst_surf_stride0x607c">RKNN_ppu_dst_surf_stride（0x607C）</a></h2>
<p>输出 surface 步长。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dst_surf_stride</code></td><td style="text-align: left">输出 shape 面积</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_data_format0x6084"><a class="header" href="#rknn_ppu_data_format0x6084">RKNN_ppu_data_format（0x6084）</a></h2>
<p>数据格式配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>index_add</code></td><td style="text-align: left">若 <code>index_en</code> 使能，值为 <code>dst_surface_stride × cube surface 数</code>（每 surface 8 字节），否则等于 <code>dst_surface_stride</code></td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dpu_flyin</code></td><td style="text-align: left">数据来自 DPU 且 DPU 数据来自外部时置 1</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>proc_precision</code></td><td style="text-align: left">处理精度</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_misc_ctrl0x60dc"><a class="header" href="#rknn_ppu_misc_ctrl0x60dc">RKNN_ppu_misc_ctrl（0x60DC）</a></h2>
<p>杂项控制：非对齐模式、多 surface 输出、burst。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>surf_len</code></td><td style="text-align: left">Surface 计数长度</td></tr>
<tr><td style="text-align: center">15:9</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>mc_surf_out</code></td><td style="text-align: left">多 surface 输出使能</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>nonalign</code></td><td style="text-align: left">非对齐模式使能</td></tr>
<tr><td style="text-align: center">6:4</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>burst_len</code></td><td style="text-align: left">Burst 长度。3：Burst4；7：Burst8；15：Burst16</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ppu_rdma-寄存器块"><a class="header" href="#ppu_rdma-寄存器块">PPU_RDMA 寄存器块</a></h1>
<p><strong>基址</strong>：<code>CORE_BASE + 0x7000</code>　｜　<strong>地址范围</strong>：<code>0x7000 ~ 0x7FFF</code></p>
<blockquote>
<p>来源：RK3588 TRM §36.4.3 Detail Registers Description</p>
</blockquote>
<p>PPU_RDMA 负责为 PPU 从外部内存读取池化输入特征数据（flying 模式下使用）。</p>
<hr />
<h2 id="rknn_ppu_rdma_s_status0x7000"><a class="header" href="#rknn_ppu_rdma_s_status0x7000">RKNN_ppu_rdma_s_status（0x7000）</a></h2>
<p>执行器状态寄存器（只读）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:18</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">17:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_1</code></td><td style="text-align: left">执行器 1 状态。0：空闲；1：正在执行；2：正在执行且等待执行；3：保留</td></tr>
<tr><td style="text-align: center">15:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>status_0</code></td><td style="text-align: left">执行器 0 状态。编码同 <code>status_1</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_rdma_s_pointer0x7004"><a class="header" href="#rknn_ppu_rdma_s_pointer0x7004">RKNN_ppu_rdma_s_pointer（0x7004）</a></h2>
<p>寄存器组指针与 ping-pong 控制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:17</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer</code></td><td style="text-align: left">当前使用的寄存器组。0：组 0；1：组 1</td></tr>
<tr><td style="text-align: center">15:6</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_clear</code></td><td style="text-align: left">清除执行器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">W1C</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_clear</code></td><td style="text-align: left">清除寄存器组指针，写 1 清零</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_mode</code></td><td style="text-align: left">Ping-pong 模式。0：按执行器切换；1：按指针切换</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>executer_pp_en</code></td><td style="text-align: left">执行器组 ping-pong 使能</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer_pp_en</code></td><td style="text-align: left">寄存器组 ping-pong 使能</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>pointer</code></td><td style="text-align: left">当前待设置的寄存器组。0：组 0；1：组 1</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_rdma_operation_enable0x7008"><a class="header" href="#rknn_ppu_rdma_operation_enable0x7008">RKNN_ppu_rdma_operation_enable（0x7008）</a></h2>
<p>操作使能。写入触发 PPU_RDMA 执行，此寄存器及之后均为 ping-pong 影子寄存器。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>op_en</code></td><td style="text-align: left">PPU_RDMA 操作使能。0：禁用；1：使能</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_rdma_cube_in_width0x700c"><a class="header" href="#rknn_ppu_rdma_cube_in_width0x700c">RKNN_ppu_rdma_cube_in_width（0x700C）</a></h2>
<p>池化输入 cube 宽度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cube_in_width</code></td><td style="text-align: left">池化 cube 宽度（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_rdma_cube_in_height0x7010"><a class="header" href="#rknn_ppu_rdma_cube_in_height0x7010">RKNN_ppu_rdma_cube_in_height（0x7010）</a></h2>
<p>池化输入 cube 高度。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cube_in_height</code></td><td style="text-align: left">池化 cube 高度（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_rdma_cube_in_channel0x7014"><a class="header" href="#rknn_ppu_rdma_cube_in_channel0x7014">RKNN_ppu_rdma_cube_in_channel（0x7014）</a></h2>
<p>池化输入 cube 通道数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cube_in_channel</code></td><td style="text-align: left">池化 cube 通道数（需减 1）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_rdma_src_base_addr0x701c"><a class="header" href="#rknn_ppu_rdma_src_base_addr0x701c">RKNN_ppu_rdma_src_base_addr（0x701C）</a></h2>
<p>池化 cube 源基址。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>src_base_addr</code></td><td style="text-align: left">池化 cube 基址</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_rdma_src_line_stride0x7024"><a class="header" href="#rknn_ppu_rdma_src_line_stride0x7024">RKNN_ppu_rdma_src_line_stride（0x7024）</a></h2>
<p>源行步长（shape 宽度）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>src_line_stride</code></td><td style="text-align: left">池化 cube shape 宽度</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_rdma_src_surf_stride0x7028"><a class="header" href="#rknn_ppu_rdma_src_surf_stride0x7028">RKNN_ppu_rdma_src_surf_stride（0x7028）</a></h2>
<p>源 surface 步长（shape 面积）。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>src_surf_stride</code></td><td style="text-align: left">池化 cube shape 面积</td></tr>
<tr><td style="text-align: center">3:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rknn_ppu_rdma_data_format0x7030"><a class="header" href="#rknn_ppu_rdma_data_format0x7030">RKNN_ppu_rdma_data_format（0x7030）</a></h2>
<p>输入数据格式。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:2</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">1:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>in_precision</code></td><td style="text-align: left">输入精度。0：4bit；1：8bit；2：16bit；3：32bit</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ddma--sdma-寄存器块data-dma--system-dma"><a class="header" href="#ddma--sdma-寄存器块data-dma--system-dma">DDMA / SDMA 寄存器块（Data DMA / System DMA）</a></h1>
<p><strong>DDMA 基址</strong>：<code>CORE_BASE + 0x8000</code>　｜　<strong>地址范围</strong>：<code>0x8000 ~ 0x8FFF</code>
<strong>SDMA 基址</strong>：<code>CORE_BASE + 0x9000</code>　｜　<strong>地址范围</strong>：<code>0x9000 ~ 0x9FFF</code></p>
<blockquote>
<p>来源：RK3588 TRM §36.4.3 Detail Registers Description</p>
</blockquote>
<p>DDMA 和 SDMA 寄存器布局完全一致，仅基址不同（DDMA <code>0x8xxx</code>，SDMA <code>0x9xxx</code>）。DDMA 用于数据搬运，SDMA 用于系统级搬运。以下以 DDMA 为例展开位域，SDMA 将偏移 <code>0x8xxx</code> 替换为 <code>0x9xxx</code> 即可。</p>
<hr />
<h2 id="cfg_outstandingddma-0x8000--sdma-0x9000"><a class="header" href="#cfg_outstandingddma-0x8000--sdma-0x9000">cfg_outstanding（DDMA: 0x8000 / SDMA: 0x9000）</a></h2>
<p>读写 outstanding 数配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">15:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_os_cnt</code></td><td style="text-align: left">最大写 outstanding 数</td></tr>
<tr><td style="text-align: center">7:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_os_cnt</code></td><td style="text-align: left">最大读 outstanding 数</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rd_weight_0ddma-0x8004--sdma-0x9004"><a class="header" href="#rd_weight_0ddma-0x8004--sdma-0x9004">rd_weight_0（DDMA: 0x8004 / SDMA: 0x9004）</a></h2>
<p>读仲裁权重 0：各模块读 burst 权重。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:24</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_weight_pdp</code></td><td style="text-align: left">PPU 读 burst 权重</td></tr>
<tr><td style="text-align: center">23:16</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_weight_dpu</code></td><td style="text-align: left">DPU 读 burst 权重</td></tr>
<tr><td style="text-align: center">15:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_weight_kernel</code></td><td style="text-align: left">权重读 burst 权重</td></tr>
<tr><td style="text-align: center">7:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_weight_feature</code></td><td style="text-align: left">特征读 burst 权重</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="wr_weight_0ddma-0x8008--sdma-0x9008"><a class="header" href="#wr_weight_0ddma-0x8008--sdma-0x9008">wr_weight_0（DDMA: 0x8008 / SDMA: 0x9008）</a></h2>
<p>写仲裁权重。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:16</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">15:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_weight_pdp</code></td><td style="text-align: left">PPU 写权重</td></tr>
<tr><td style="text-align: center">7:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_weight_dpu</code></td><td style="text-align: left">DPU 写权重</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="cfg_id_errorddma-0x800c--sdma-0x900c"><a class="header" href="#cfg_id_errorddma-0x800c--sdma-0x900c">cfg_id_error（DDMA: 0x800C / SDMA: 0x900C）</a></h2>
<p>错误 ID 记录。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:10</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">9:6</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_resp_id</code></td><td style="text-align: left">错误写 ID</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">4:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_resp_id</code></td><td style="text-align: left">错误读 ID</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="rd_weight_1ddma-0x8010--sdma-0x9010"><a class="header" href="#rd_weight_1ddma-0x8010--sdma-0x9010">rd_weight_1（DDMA: 0x8010 / SDMA: 0x9010）</a></h2>
<p>读仲裁权重 1：PC 读 burst 权重。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:8</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">7:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_weight_pc</code></td><td style="text-align: left">PC 读 burst 权重</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="cfg_dma_fifo_clrddma-0x8014--sdma-0x9014"><a class="header" href="#cfg_dma_fifo_clrddma-0x8014--sdma-0x9014">cfg_dma_fifo_clr（DDMA: 0x8014 / SDMA: 0x9014）</a></h2>
<p>清除 DMA FIFO。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dma_fifo_clr</code></td><td style="text-align: left">清除 DMA FIFO</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="cfg_dma_arbddma-0x8018--sdma-0x9018"><a class="header" href="#cfg_dma_arbddma-0x8018--sdma-0x9018">cfg_dma_arb（DDMA: 0x8018 / SDMA: 0x9018）</a></h2>
<p>DMA 仲裁模式配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:10</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">9</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_arbit_model</code></td><td style="text-align: left">写仲裁模型</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_arbit_model</code></td><td style="text-align: left">读仲裁模型</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">6:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_fix_arb</code></td><td style="text-align: left">写固定仲裁</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_fix_arb</code></td><td style="text-align: left">读固定仲裁</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="cfg_dma_rd_qosddma-0x8020--sdma-0x9020"><a class="header" href="#cfg_dma_rd_qosddma-0x8020--sdma-0x9020">cfg_dma_rd_qos（DDMA: 0x8020 / SDMA: 0x9020）</a></h2>
<p>各模块读 QoS 配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:10</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">9:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_pc_qos</code></td><td style="text-align: left">PC 读 QoS</td></tr>
<tr><td style="text-align: center">7:6</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_ppu_qos</code></td><td style="text-align: left">PPU 读 QoS</td></tr>
<tr><td style="text-align: center">5:4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_dpu_qos</code></td><td style="text-align: left">DPU 读 QoS</td></tr>
<tr><td style="text-align: center">3:2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_kernel_qos</code></td><td style="text-align: left">Kernel 读 QoS</td></tr>
<tr><td style="text-align: center">1:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_feature_qos</code></td><td style="text-align: left">Feature 读 QoS</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="cfg_dma_rd_cfgddma-0x8024--sdma-0x9024"><a class="header" href="#cfg_dma_rd_cfgddma-0x8024--sdma-0x9024">cfg_dma_rd_cfg（DDMA: 0x8024 / SDMA: 0x9024）</a></h2>
<p>AXI 读通道信号配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_arlock</code></td><td style="text-align: left">AXI arlock</td></tr>
<tr><td style="text-align: center">11:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_arcache</code></td><td style="text-align: left">AXI arcache</td></tr>
<tr><td style="text-align: center">7:5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_arprot</code></td><td style="text-align: left">AXI arprot</td></tr>
<tr><td style="text-align: center">4:3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_arburst</code></td><td style="text-align: left">AXI arburst</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>rd_arsize</code></td><td style="text-align: left">AXI arsize</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="cfg_dma_wr_cfgddma-0x8028--sdma-0x9028"><a class="header" href="#cfg_dma_wr_cfgddma-0x8028--sdma-0x9028">cfg_dma_wr_cfg（DDMA: 0x8028 / SDMA: 0x9028）</a></h2>
<p>AXI 写通道信号配置。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:13</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">12</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_awlock</code></td><td style="text-align: left">AXI awlock</td></tr>
<tr><td style="text-align: center">11:8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_awcache</code></td><td style="text-align: left">AXI awcache</td></tr>
<tr><td style="text-align: center">7:5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_awprot</code></td><td style="text-align: left">AXI awprot</td></tr>
<tr><td style="text-align: center">4:3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_awburst</code></td><td style="text-align: left">AXI awburst</td></tr>
<tr><td style="text-align: center">2:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_awsize</code></td><td style="text-align: left">AXI awsize</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="cfg_dma_wstrbddma-0x802c--sdma-0x902c"><a class="header" href="#cfg_dma_wstrbddma-0x802c--sdma-0x902c">cfg_dma_wstrb（DDMA: 0x802C / SDMA: 0x902C）</a></h2>
<p>AXI 写选通。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>wr_wstrb</code></td><td style="text-align: left">AXI 写选通信号</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="cfg_statusddma-0x8030--sdma-0x9030"><a class="header" href="#cfg_statusddma-0x8030--sdma-0x9030">cfg_status（DDMA: 0x8030 / SDMA: 0x9030）</a></h2>
<p>DMA 状态。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:9</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>idel</code></td><td style="text-align: left">空闲状态</td></tr>
<tr><td style="text-align: center">7:0</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="附ddma-统计寄存器ioctlh-定义"><a class="header" href="#附ddma-统计寄存器ioctlh-定义">附：DDMA 统计寄存器（ioctl.h 定义）</a></h2>
<p>以下寄存器偏移来自 <span style="background:#e3f2fd;padding:1px 4px;border-radius:3px;font-size:0.8em">rknpu-ioctl.h</span>，用于 <code>ACTION</code> 类 ioctl 读取读写量统计：</p>
<div class="table-wrapper"><table><thead><tr><th>偏移</th><th>名称</th><th>说明</th><th>关联 Action</th></tr></thead><tbody>
<tr><td><code>0x8010</code></td><td><code>CLR_ALL_RW_AMOUNT</code></td><td>清除全部读写量统计</td><td><code>ActClrTotalRwAmount</code></td></tr>
<tr><td><code>0x8034</code></td><td><code>DT_WR_AMOUNT</code></td><td>数据写入量</td><td><code>GetDtWrAmount</code></td></tr>
<tr><td><code>0x8038</code></td><td><code>DT_RD_AMOUNT</code></td><td>数据读取量</td><td><code>GetDtRdAmount</code></td></tr>
<tr><td><code>0x803C</code></td><td><code>WT_RD_AMOUNT</code></td><td>权重读取量</td><td><code>GetWtRdAmount</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>清除操作</strong> <span style="background:#fff3e0;padding:1px 4px;border-radius:3px;font-size:0.8em">StarryOS Rust 驱动</span>：写 <code>0x80000101</code> 再写 <code>0x00000101</code>（两次写入进行 latch/clear）。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-寄存器块全局使能"><a class="header" href="#global-寄存器块全局使能">GLOBAL 寄存器块（全局使能）</a></h1>
<p><strong>基址</strong>：<code>CORE_BASE + 0xF000</code>　｜　<strong>地址范围</strong>：<code>0xF000 ~ 0xFFFF</code></p>
<blockquote>
<p>来源：RK3588 TRM §36.4.3 Detail Registers Description</p>
</blockquote>
<p>GLOBAL 模块仅包含一个寄存器，用于一次性组合使能各功能模块的操作。</p>
<hr />
<h2 id="rknn_global_operation_enable0xf008"><a class="header" href="#rknn_global_operation_enable0xf008">RKNN_global_operation_enable（0xF008）</a></h2>
<p>组合操作使能：一次写入同时触发多个模块开始执行。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: center">属性</th><th style="text-align: center">复位值</th><th style="text-align: left">字段名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: center">31:7</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ppu_rdma_op_en</code></td><td style="text-align: left">PPU_RDMA 操作使能</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>ppu_op_en</code></td><td style="text-align: left">PPU 操作使能</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dpu_rdma_op_en</code></td><td style="text-align: left">DPU_RDMA 操作使能</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>dpu_op_en</code></td><td style="text-align: left">DPU 操作使能</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>core_op_en</code></td><td style="text-align: left">CORE 操作使能</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">RO</td><td style="text-align: center">0x0</td><td style="text-align: left">—</td><td style="text-align: left">保留</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">RW</td><td style="text-align: center">0x0</td><td style="text-align: left"><code>cna_op_en</code></td><td style="text-align: left">CNA 操作使能</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ioctl-协议与数据结构"><a class="header" href="#ioctl-协议与数据结构">IOCTL 协议与数据结构</a></h1>
<p>本章整理 RKNPU 驱动的全部 ioctl 命令、传参结构体布局、flags 枚举，以及 <code>mmap(offset)</code> 编码规则。</p>
<hr />
<h2 id="1-ioctl-命令表"><a class="header" href="#1-ioctl-命令表">1. IOCTL 命令表</a></h2>
<p>RKNPU 驱动提供 <strong>6 个 ioctl 命令</strong>，同时定义了两套编号：</p>
<table>
<tr>
<th>命令</th><th>编号</th><th>DRM 路径宏</th><th>非 DRM 路径宏</th><th>方向</th><th>结构体</th><th>功能</th>
</tr>
<tr>
<td><strong>ACTION</strong></td><td><code>0x00</code></td>
<td><code>DRM_IOCTL_RKNPU_ACTION</code></td>
<td><code>IOCTL_RKNPU_ACTION</code></td>
<td>IOWR</td>
<td><code>rknpu_action</code></td>
<td>查询/设置：版本、频率、电压、电源、统计、复位等</td>
</tr>
<tr>
<td><strong>SUBMIT</strong></td><td><code>0x01</code></td>
<td><code>DRM_IOCTL_RKNPU_SUBMIT</code></td>
<td><code>IOCTL_RKNPU_SUBMIT</code></td>
<td>IOWR</td>
<td><code>rknpu_submit</code></td>
<td>提交 NPU 任务（PC job）</td>
</tr>
<tr>
<td><strong>MEM_CREATE</strong></td><td><code>0x02</code></td>
<td><code>DRM_IOCTL_RKNPU_MEM_CREATE</code></td>
<td><code>IOCTL_RKNPU_MEM_CREATE</code></td>
<td>IOWR</td>
<td><code>rknpu_mem_create</code></td>
<td>分配 DMA buffer（GEM 对象）</td>
</tr>
<tr>
<td><strong>MEM_MAP</strong></td><td><code>0x03</code></td>
<td><code>DRM_IOCTL_RKNPU_MEM_MAP</code></td>
<td><code>IOCTL_RKNPU_MEM_MAP</code></td>
<td>IOWR</td>
<td><code>rknpu_mem_map</code></td>
<td>获取 mmap 用的 fake offset</td>
</tr>
<tr>
<td><strong>MEM_DESTROY</strong></td><td><code>0x04</code></td>
<td><code>DRM_IOCTL_RKNPU_MEM_DESTROY</code></td>
<td><code>IOCTL_RKNPU_MEM_DESTROY</code></td>
<td>IOWR</td>
<td><code>rknpu_mem_destroy</code></td>
<td>释放 DMA buffer</td>
</tr>
<tr>
<td><strong>MEM_SYNC</strong></td><td><code>0x05</code></td>
<td><code>DRM_IOCTL_RKNPU_MEM_SYNC</code></td>
<td><code>IOCTL_RKNPU_MEM_SYNC</code></td>
<td>IOWR</td>
<td><code>rknpu_mem_sync</code></td>
<td>Cache 同步（flush / invalidate）</td>
</tr>
</table>
<h3 id="11-两套编号的区别"><a class="header" href="#11-两套编号的区别">1.1 两套编号的区别</a></h3>
<table>
<tr><th></th><th>DRM 路径</th><th>非 DRM 路径</th></tr>
<tr>
<td><strong>编码方式</strong></td>
<td><code>DRM_IOWR(DRM_COMMAND_BASE + nr, type)</code></td>
<td><code>_IOWR('r', nr, type)</code></td>
</tr>
<tr>
<td><strong>设备节点</strong></td>
<td><code>/dev/dri/cardX</code></td>
<td><code>/dev/rknpu</code>（如果驱动注册了）</td>
</tr>
<tr>
<td><strong>调用方式</strong></td>
<td><code>drmIoctl(fd, DRM_IOCTL_RKNPU_*, &arg)</code></td>
<td><code>ioctl(fd, IOCTL_RKNPU_*, &arg)</code></td>
</tr>
<tr>
<td><strong>闭源库使用</strong></td>
<td> <code>librknnrt.so</code> 主要走此路径</td>
<td>备选</td>
</tr>
</table>
<blockquote>
<p><span style="background:#e3f2fd;padding:1px 4px;border-radius:3px;font-size:0.8em">rknpu-ioctl.h</span> 中 <code>RKNPU_IOC_MAGIC = 'r'</code>，<code>DRM_COMMAND_BASE</code> 来自 <code>&lt;libdrm/drm.h&gt;</code>（通常为 <code>0x40</code>）。</p>
</blockquote>
<hr />
<h2 id="2-结构体布局"><a class="header" href="#2-结构体布局">2. 结构体布局</a></h2>
<h3 id="21-struct-rknpu_action8-字节"><a class="header" href="#21-struct-rknpu_action8-字节">2.1 <code>struct rknpu_action</code>（8 字节）</a></h3>
<p>用于 <code>ACTION</code> ioctl，查询/设置各种属性。</p>
<table>
<tr><th>偏移</th><th>大小</th><th>类型</th><th>字段</th><th>说明</th></tr>
<tr><td><code>0x00</code></td><td>4</td><td><code>__u32</code></td><td><code>flags</code></td><td>Action 编号（见 §3.4）</td></tr>
<tr><td><code>0x04</code></td><td>4</td><td><code>__u32</code></td><td><code>value</code></td><td>GET 时为返回值，SET 时为输入值</td></tr>
</table>
<h3 id="22-struct-rknpu_mem_create40-字节"><a class="header" href="#22-struct-rknpu_mem_create40-字节">2.2 <code>struct rknpu_mem_create</code>（40 字节）</a></h3>
<table>
<tr><th>偏移</th><th>大小</th><th>类型</th><th>字段</th><th>方向</th><th>说明</th></tr>
<tr><td><code>0x00</code></td><td>4</td><td><code>__u32</code></td><td><code>handle</code></td><td>OUT</td><td>GEM 对象句柄（驱动分配）</td></tr>
<tr><td><code>0x04</code></td><td>4</td><td><code>__u32</code></td><td><code>flags</code></td><td>IN</td><td>内存类型 flags（见 §3.1）</td></tr>
<tr><td><code>0x08</code></td><td>8</td><td><code>__u64</code></td><td><code>size</code></td><td>IN</td><td>申请大小（内部页对齐）</td></tr>
<tr><td><code>0x10</code></td><td>8</td><td><code>__u64</code></td><td><code>obj_addr</code></td><td>OUT</td><td>内核对象地址（opaque token）</td></tr>
<tr><td><code>0x18</code></td><td>8</td><td><code>__u64</code></td><td><code>dma_addr</code></td><td>OUT</td><td>设备侧 DMA 地址（IOVA 或物理地址）</td></tr>
<tr><td><code>0x20</code></td><td>8</td><td><code>__u64</code></td><td><code>sram_size</code></td><td>IN</td><td>可选 SRAM 申请大小</td></tr>
</table>
<blockquote>
<p><span style="background:#fff3e0;padding:1px 4px;border-radius:3px;font-size:0.8em">StarryOS Rust 驱动</span> 扩展了额外字段：<code>iommu_domain_id: i32</code>、<code>core_mask: u32</code>，用于多核/IOMMU 域管理。</p>
</blockquote>
<h3 id="23-struct-rknpu_mem_map16-字节"><a class="header" href="#23-struct-rknpu_mem_map16-字节">2.3 <code>struct rknpu_mem_map</code>（16 字节）</a></h3>
<table>
<tr><th>偏移</th><th>大小</th><th>类型</th><th>字段</th><th>方向</th><th>说明</th></tr>
<tr><td><code>0x00</code></td><td>4</td><td><code>__u32</code></td><td><code>handle</code></td><td>IN</td><td>GEM 句柄</td></tr>
<tr><td><code>0x04</code></td><td>4</td><td><code>__u32</code></td><td><code>reserved</code></td><td>—</td><td>64 位对齐填充</td></tr>
<tr><td><code>0x08</code></td><td>8</td><td><code>__u64</code></td><td><code>offset</code></td><td>OUT</td><td>fake offset，用于 <code>mmap(fd, ..., offset)</code></td></tr>
</table>
<h3 id="24-struct-rknpu_mem_destroy16-字节"><a class="header" href="#24-struct-rknpu_mem_destroy16-字节">2.4 <code>struct rknpu_mem_destroy</code>（16 字节）</a></h3>
<table>
<tr><th>偏移</th><th>大小</th><th>类型</th><th>字段</th><th>方向</th><th>说明</th></tr>
<tr><td><code>0x00</code></td><td>4</td><td><code>__u32</code></td><td><code>handle</code></td><td>IN</td><td>GEM 句柄</td></tr>
<tr><td><code>0x04</code></td><td>4</td><td><code>__u32</code></td><td><code>reserved</code></td><td>—</td><td>填充</td></tr>
<tr><td><code>0x08</code></td><td>8</td><td><code>__u64</code></td><td><code>obj_addr</code></td><td>IN</td><td>内核对象地址</td></tr>
</table>
<h3 id="25-struct-rknpu_mem_sync32-字节"><a class="header" href="#25-struct-rknpu_mem_sync32-字节">2.5 <code>struct rknpu_mem_sync</code>（32 字节）</a></h3>
<table>
<tr><th>偏移</th><th>大小</th><th>类型</th><th>字段</th><th>方向</th><th>说明</th></tr>
<tr><td><code>0x00</code></td><td>4</td><td><code>__u32</code></td><td><code>flags</code></td><td>IN</td><td>同步方向（见 §3.2）</td></tr>
<tr><td><code>0x04</code></td><td>4</td><td><code>__u32</code></td><td><code>reserved</code></td><td>—</td><td>填充</td></tr>
<tr><td><code>0x08</code></td><td>8</td><td><code>__u64</code></td><td><code>obj_addr</code></td><td>IN</td><td>要同步的内核对象地址</td></tr>
<tr><td><code>0x10</code></td><td>8</td><td><code>__u64</code></td><td><code>offset</code></td><td>IN</td><td>同步起始偏移（字节）</td></tr>
<tr><td><code>0x18</code></td><td>8</td><td><code>__u64</code></td><td><code>size</code></td><td>IN</td><td>同步区域大小</td></tr>
</table>
<h3 id="26-struct-rknpu_task36-字节__packed"><a class="header" href="#26-struct-rknpu_task36-字节__packed">2.6 <code>struct rknpu_task</code>（36 字节，<code>__packed</code>）</a></h3>
<p>单个任务描述，由 PC 命令流引擎解释执行。</p>
<table>
<tr><th>偏移</th><th>大小</th><th>类型</th><th>字段</th><th>说明</th></tr>
<tr><td><code>0x00</code></td><td>4</td><td><code>__u32</code></td><td><code>flags</code></td><td>任务标志</td></tr>
<tr><td><code>0x04</code></td><td>4</td><td><code>__u32</code></td><td><code>op_idx</code></td><td>算子索引</td></tr>
<tr><td><code>0x08</code></td><td>4</td><td><code>__u32</code></td><td><code>enable_mask</code></td><td>模块使能掩码</td></tr>
<tr><td><code>0x0C</code></td><td>4</td><td><code>__u32</code></td><td><code>int_mask</code></td><td>期望的完成中断掩码</td></tr>
<tr><td><code>0x10</code></td><td>4</td><td><code>__u32</code></td><td><code>int_clear</code></td><td>中断清除值</td></tr>
<tr><td><code>0x14</code></td><td>4</td><td><code>__u32</code></td><td><code>int_status</code></td><td>完成后驱动写回实际中断状态</td></tr>
<tr><td><code>0x18</code></td><td>4</td><td><code>__u32</code></td><td><code>regcfg_amount</code></td><td>寄存器配置项数量</td></tr>
<tr><td><code>0x1C</code></td><td>4</td><td><code>__u32</code></td><td><code>regcfg_offset</code></td><td>寄存器配置在命令流中的偏移</td></tr>
<tr><td><code>0x20</code></td><td>8</td><td><code>__u64</code></td><td><code>regcmd_addr</code></td><td>寄存器命令流 DMA 地址</td></tr>
</table>
<blockquote>
<p><strong><code>__packed</code></strong>：编译器不插入 padding，保证与内核侧布局一致。</p>
</blockquote>
<h3 id="27-struct-rknpu_subcore_task8-字节"><a class="header" href="#27-struct-rknpu_subcore_task8-字节">2.7 <code>struct rknpu_subcore_task</code>（8 字节）</a></h3>
<table>
<tr><th>偏移</th><th>大小</th><th>类型</th><th>字段</th><th>说明</th></tr>
<tr><td><code>0x00</code></td><td>4</td><td><code>__u32</code></td><td><code>task_start</code></td><td>该子核心的起始 task 索引</td></tr>
<tr><td><code>0x04</code></td><td>4</td><td><code>__u32</code></td><td><code>task_number</code></td><td>该子核心要执行的 task 数量</td></tr>
</table>
<h3 id="28-struct-rknpu_submit96-字节"><a class="header" href="#28-struct-rknpu_submit96-字节">2.8 <code>struct rknpu_submit</code>（96 字节）</a></h3>
<p>任务提交主结构体，驱动最核心的入口。</p>
<table>
<tr><th>偏移</th><th>大小</th><th>类型</th><th>字段</th><th>说明</th></tr>
<tr><td><code>0x00</code></td><td>4</td><td><code>__u32</code></td><td><code>flags</code></td><td>Job 模式（见 §3.3）</td></tr>
<tr><td><code>0x04</code></td><td>4</td><td><code>__u32</code></td><td><code>timeout</code></td><td>超时时间（ms）</td></tr>
<tr><td><code>0x08</code></td><td>4</td><td><code>__u32</code></td><td><code>task_start</code></td><td>全局起始 task 索引</td></tr>
<tr><td><code>0x0C</code></td><td>4</td><td><code>__u32</code></td><td><code>task_number</code></td><td>全局 task 数量</td></tr>
<tr><td><code>0x10</code></td><td>4</td><td><code>__u32</code></td><td><code>task_counter</code></td><td>计数/序列号</td></tr>
<tr><td><code>0x14</code></td><td>4</td><td><code>__s32</code></td><td><code>priority</code></td><td>调度优先级</td></tr>
<tr><td><code>0x18</code></td><td>8</td><td><code>__u64</code></td><td><code>task_obj_addr</code></td><td>task 数组的内核对象地址</td></tr>
<tr><td><code>0x20</code></td><td>8</td><td><code>__u64</code></td><td><code>regcfg_obj_addr</code></td><td>寄存器配置对象地址</td></tr>
<tr><td><code>0x28</code></td><td>8</td><td><code>__u64</code></td><td><code>task_base_addr</code></td><td>task 基址（设备侧）</td></tr>
<tr><td><code>0x30</code></td><td>8</td><td><code>__u64</code></td><td><code>user_data</code></td><td>可选用户数据（透传/调试）</td></tr>
<tr><td><code>0x38</code></td><td>4</td><td><code>__u32</code></td><td><code>core_mask</code></td><td>核心选择掩码（bit0=core0, bit1=core1, bit2=core2）</td></tr>
<tr><td><code>0x3C</code></td><td>4</td><td><code>__s32</code></td><td><code>fence_fd</code></td><td>dma-fence fd（IN: fence_in, OUT: fence_out）</td></tr>
<tr><td><code>0x40</code></td><td>40</td><td><code>subcore_task[5]</code></td><td><code>subcore_task</code></td><td>5 组子核心任务分配</td></tr>
</table>
<blockquote>
<p><span style="background:#fff3e0;padding:1px 4px;border-radius:3px;font-size:0.8em">StarryOS Rust 驱动</span> 变体：将 <code>regcfg_obj_addr</code> 替换为 <code>iommu_domain_id</code> + <code>reserved</code>，并增加 <code>hw_elapse_time</code> 字段。</p>
</blockquote>
<hr />
<h2 id="3-flags-枚举"><a class="header" href="#3-flags-枚举">3. Flags 枚举</a></h2>
<h3 id="31-enum-e_rknpu_mem_type内存类型位掩码"><a class="header" href="#31-enum-e_rknpu_mem_type内存类型位掩码">3.1 <code>enum e_rknpu_mem_type</code>（内存类型，位掩码）</a></h3>
<table>
<tr><th>值</th><th>名称</th><th>说明</th></tr>
<tr><td><code>0 &lt;&lt; 0</code></td><td><code>CONTIGUOUS</code></td><td>物理连续（默认）</td></tr>
<tr><td><code>1 &lt;&lt; 0</code></td><td><code>NON_CONTIGUOUS</code></td><td>物理不连续</td></tr>
<tr><td><code>0 &lt;&lt; 1</code></td><td><code>NON_CACHEABLE</code></td><td>不可缓存（默认）</td></tr>
<tr><td><code>1 &lt;&lt; 1</code></td><td><code>CACHEABLE</code></td><td>可缓存</td></tr>
<tr><td><code>1 &lt;&lt; 2</code></td><td><code>WRITE_COMBINE</code></td><td>Write-Combine 映射</td></tr>
<tr><td><code>1 &lt;&lt; 3</code></td><td><code>KERNEL_MAPPING</code></td><td>内核态映射</td></tr>
<tr><td><code>1 &lt;&lt; 4</code></td><td><code>IOMMU</code></td><td>IOMMU 映射</td></tr>
<tr><td><code>1 &lt;&lt; 5</code></td><td><code>ZEROING</code></td><td>分配后清零</td></tr>
<tr><td><code>1 &lt;&lt; 6</code></td><td><code>SECURE</code></td><td>安全内存</td></tr>
<tr><td><code>1 &lt;&lt; 7</code></td><td><code>NON_DMA32</code></td><td>不限于 DMA32 区域</td></tr>
<tr><td><code>1 &lt;&lt; 8</code></td><td><code>TRY_ALLOC_SRAM</code></td><td>尝试分配 SRAM</td></tr>
</table>
<p><code>MEM_MASK = 0x1FF</code>（bit0~bit8 的合法组合集）</p>
<h3 id="32-enum-e_rknpu_mem_sync_modecache-同步方向"><a class="header" href="#32-enum-e_rknpu_mem_sync_modecache-同步方向">3.2 <code>enum e_rknpu_mem_sync_mode</code>（Cache 同步方向）</a></h3>
<div class="table-wrapper"><table><thead><tr><th>值</th><th>名称</th><th>说明</th></tr></thead><tbody>
<tr><td><code>1 &lt;&lt; 0</code></td><td><code>SYNC_TO_DEVICE</code></td><td>CPU → 设备：flush cache</td></tr>
<tr><td><code>1 &lt;&lt; 1</code></td><td><code>SYNC_FROM_DEVICE</code></td><td>设备 → CPU：invalidate cache</td></tr>
</tbody></table>
</div>
<h3 id="33-enum-e_rknpu_job_modejob-模式位掩码"><a class="header" href="#33-enum-e_rknpu_job_modejob-模式位掩码">3.3 <code>enum e_rknpu_job_mode</code>（Job 模式，位掩码）</a></h3>
<table>
<tr><th>值</th><th>名称</th><th>说明</th></tr>
<tr><td><code>0 &lt;&lt; 0</code></td><td><code>SLAVE</code></td><td>从模式（默认）</td></tr>
<tr><td><code>1 &lt;&lt; 0</code></td><td><code>PC</code></td><td>PC（Program Counter）模式</td></tr>
<tr><td><code>0 &lt;&lt; 1</code></td><td><code>BLOCK</code></td><td>阻塞等待完成（默认）</td></tr>
<tr><td><code>1 &lt;&lt; 1</code></td><td><code>NONBLOCK</code></td><td>非阻塞返回</td></tr>
<tr><td><code>1 &lt;&lt; 2</code></td><td><code>PINGPONG</code></td><td>双缓冲/流水模式</td></tr>
<tr><td><code>1 &lt;&lt; 3</code></td><td><code>FENCE_IN</code></td><td>等待输入 fence</td></tr>
<tr><td><code>1 &lt;&lt; 4</code></td><td><code>FENCE_OUT</code></td><td>返回输出 fence fd</td></tr>
</table>
<h3 id="34-enum-e_rknpu_actionaction-编号"><a class="header" href="#34-enum-e_rknpu_actionaction-编号">3.4 <code>enum e_rknpu_action</code>（Action 编号）</a></h3>
<table>
<tr><th>编号</th><th>名称</th><th>方向</th><th>说明</th></tr>
<tr><td>0</td><td><code>GET_HW_VERSION</code></td><td>GET</td><td>读取硬件版本</td></tr>
<tr><td>1</td><td><code>GET_DRV_VERSION</code></td><td>GET</td><td>读取驱动版本（编码：major*10000+minor*100+patch）</td></tr>
<tr><td>2</td><td><code>GET_FREQ</code></td><td>GET</td><td>读取当前频率</td></tr>
<tr><td>3</td><td><code>SET_FREQ</code></td><td>SET</td><td>设置频率</td></tr>
<tr><td>4</td><td><code>GET_VOLT</code></td><td>GET</td><td>读取电压</td></tr>
<tr><td>5</td><td><code>SET_VOLT</code></td><td>SET</td><td>设置电压</td></tr>
<tr><td>6</td><td><code>ACT_RESET</code></td><td>ACT</td><td>NPU 软复位</td></tr>
<tr><td>7</td><td><code>GET_BW_PRIORITY</code></td><td>GET</td><td>带宽优先级</td></tr>
<tr><td>8</td><td><code>SET_BW_PRIORITY</code></td><td>SET</td><td>设置带宽优先级</td></tr>
<tr><td>9</td><td><code>GET_BW_EXPECT</code></td><td>GET</td><td>期望带宽</td></tr>
<tr><td>10</td><td><code>SET_BW_EXPECT</code></td><td>SET</td><td>设置期望带宽</td></tr>
<tr><td>11</td><td><code>GET_BW_TW</code></td><td>GET</td><td>带宽时间窗</td></tr>
<tr><td>12</td><td><code>SET_BW_TW</code></td><td>SET</td><td>设置带宽时间窗</td></tr>
<tr><td>13</td><td><code>ACT_CLR_TOTAL_RW_AMOUNT</code></td><td>ACT</td><td>清除读写量统计</td></tr>
<tr><td>14</td><td><code>GET_DT_WR_AMOUNT</code></td><td>GET</td><td>数据写入量</td></tr>
<tr><td>15</td><td><code>GET_DT_RD_AMOUNT</code></td><td>GET</td><td>数据读取量</td></tr>
<tr><td>16</td><td><code>GET_WT_RD_AMOUNT</code></td><td>GET</td><td>权重读取量</td></tr>
<tr><td>17</td><td><code>GET_TOTAL_RW_AMOUNT</code></td><td>GET</td><td>总读写量</td></tr>
<tr><td>18</td><td><code>GET_IOMMU_EN</code></td><td>GET</td><td>IOMMU 是否启用</td></tr>
<tr><td>19</td><td><code>SET_PROC_NICE</code></td><td>SET</td><td>进程优先级</td></tr>
<tr><td>20</td><td><code>POWER_ON</code></td><td>ACT</td><td>NPU 上电</td></tr>
<tr><td>21</td><td><code>POWER_OFF</code></td><td>ACT</td><td>NPU 下电</td></tr>
<tr><td>22</td><td><code>GET_TOTAL_SRAM_SIZE</code></td><td>GET</td><td>SRAM 总大小</td></tr>
<tr><td>23</td><td><code>GET_FREE_SRAM_SIZE</code></td><td>GET</td><td>SRAM 空闲大小</td></tr>
<tr style="background:#fff3e0">
<td>24</td><td><code>GET_IOMMU_DOMAIN_ID</code></td><td>GET</td><td><em>StarryOS 扩展</em></td></tr>
<tr style="background:#fff3e0">
<td>25</td><td><code>SET_IOMMU_DOMAIN_ID</code></td><td>SET</td><td><em>StarryOS 扩展</em></td></tr>
</table>
<hr />
<h2 id="4-mmap-规则handle--offset-编码"><a class="header" href="#4-mmap-规则handle--offset-编码">4. mmap 规则（handle → offset 编码）</a></h2>
<h3 id="41-流程"><a class="header" href="#41-流程">4.1 流程</a></h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant U as 用户态
    participant K as 内核驱动

    U-&gt;&gt;K: ioctl(MEM_CREATE, {size, flags})
    K--&gt;&gt;U: {handle, obj_addr, dma_addr}

    U-&gt;&gt;K: ioctl(MEM_MAP, {handle})
    K--&gt;&gt;U: {offset}

    U-&gt;&gt;U: ptr = mmap(fd, size, PROT_RW, MAP_SHARED, fd, offset)
    Note over U: 现在 ptr 指向 DMA buffer 的用户态映射

    U-&gt;&gt;K: ioctl(MEM_SYNC, {obj_addr, offset=0, size, flags=TO_DEVICE})
    Note over K: flush CPU cache → 设备可见

    Note over U,K: ... 使用 buffer（填充数据 / 读取结果）...

    U-&gt;&gt;K: ioctl(MEM_DESTROY, {handle, obj_addr})
    Note over K: 释放 GEM 对象 + DMA 内存
</code></pre>
<h3 id="42-offset-编码约定"><a class="header" href="#42-offset-编码约定">4.2 offset 编码约定</a></h3>
<p><span style="background:#e8f5e9;padding:1px 4px;border-radius:3px;font-size:0.8em">Linux rknpu 驱动</span> 中，<code>MEM_MAP</code> 返回的 <code>offset</code> 是 DRM GEM 的 <strong>fake offset</strong>：</p>
<ul>
<li>由 <code>drm_gem_create_mmap_offset()</code> 生成</li>
<li>编码方式：<code>offset = handle_to_node_offset</code>（DRM 内部维护的映射表）</li>
<li>用户态拿到 <code>offset</code> 后，传给 <code>mmap()</code> 的最后一个参数</li>
<li>内核在 <code>drm_gem_mmap()</code> 中根据 offset 查找对应的 GEM 对象，建立页表映射</li>
</ul>
<blockquote>
<p><strong>StarryOS 实现</strong>：由于没有完整 DRM 框架，需要自行维护 handle → 物理页的映射表，并在 <code>sys_mmap</code> 的 <code>DeviceMmap::Physical</code> 路径中完成映射。</p>
</blockquote>
<h3 id="43-对齐要求"><a class="header" href="#43-对齐要求">4.3 对齐要求</a></h3>
<ul>
<li><code>size</code>：内部页对齐（4KB）</li>
<li><code>offset</code>：必须页对齐</li>
<li><code>dma_addr</code>：取决于是否启用 IOMMU
<ul>
<li>有 IOMMU：返回 IOVA（设备虚拟地址）</li>
<li>无 IOMMU：返回物理地址（需物理连续）</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rknn-用户库手册"><a class="header" href="#rknn-用户库手册">RKNN 用户库手册</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p><code>librknnrt.so</code> 是 Rockchip 提供的<strong>闭源</strong> NPU 运行时库，负责将神经网络模型编译为硬件命令流并提交给内核驱动执行。它是用户态与 NPU 硬件之间的桥梁。</p>
<h2 id="架构层次"><a class="header" href="#架构层次">架构层次</a></h2>
<pre><code>┌─────────────────────────────────────────────────┐
│              用户应用程序                          │
├─────────────────────────────────────────────────┤
│  rknn_api.h          │  rknn_matmul_api.h       │  ← 闭源库公开头文件
├──────────────────────┼──────────────────────────┤
│  librknnrt.so（闭源）                             │
│  ┌──────────┐ ┌──────────┐ ┌──────────────────┐ │
│  │模型解析器 │ │图优化/编译│ │命令流生成 + Task │ │
│  └──────────┘ └──────────┘ └──────────────────┘ │
├─────────────────────────────────────────────────┤
│  DRM ioctl (DRM_IOCTL_RKNPU_*)                  │  ← 开源 ABI
├─────────────────────────────────────────────────┤
│  rknpu 内核驱动（开源 GPL）                       │
│  任务调度 │ GEM 内存 │ 中断处理 │ PC 寄存器写入   │
├─────────────────────────────────────────────────┤
│  NPU 硬件（CNA / CORE / DPU / PPU）              │
└─────────────────────────────────────────────────┘
</code></pre>
<h2 id="两条-npu-使用路径"><a class="header" href="#两条-npu-使用路径">两条 NPU 使用路径</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">路径</th><th style="text-align: left">依赖</th><th style="text-align: left">操作方式</th><th style="text-align: left">代表项目</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>闭源 API 路径</strong></td><td style="text-align: left"><code>librknnrt.so</code></td><td style="text-align: left"><code>rknn_init → rknn_run → rknn_outputs_get</code></td><td style="text-align: left">yolov8 demo</td></tr>
<tr><td style="text-align: left"><strong>裸 ioctl 路径</strong></td><td style="text-align: left">仅 <code>libdrm</code> + 内核驱动</td><td style="text-align: left">用户自行构造命令流 + <code>DRM_IOCTL_RKNPU_SUBMIT</code></td><td style="text-align: left">npu_benchmark / npu_llama</td></tr>
</tbody></table>
</div>
<p>闭源库封装了命令流生成、内存规划、多核调度等全部复杂逻辑；裸 ioctl 路径则要求用户自己实现这些。</p>
<h2 id="闭源库提供的三套-api"><a class="header" href="#闭源库提供的三套-api">闭源库提供的三套 API</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">头文件</th><th style="text-align: left">功能</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>rknn_api.h</code></td><td style="text-align: left">模型推理</td><td style="text-align: left">加载 .rknn 模型 → 设置输入 → 推理 → 获取输出</td></tr>
<tr><td style="text-align: left"><code>rknn_matmul_api.h</code></td><td style="text-align: left">矩阵乘法加速</td><td style="text-align: left">独立于模型推理的通用 matmul 接口</td></tr>
<tr><td style="text-align: left"><code>rknn_custom_op.h</code></td><td style="text-align: left">自定义算子</td><td style="text-align: left">注册用户实现的 CPU/GPU 算子回调</td></tr>
</tbody></table>
</div>
<h2 id="闭源库二进制"><a class="header" href="#闭源库二进制">闭源库二进制</a></h2>
<p>仓库中 <code>test/starrynpu/demo/yolov8/3rdparty/</code> 包含实际二进制：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">文件</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>rknpu2/Linux/aarch64/librknnrt.so</code></td><td style="text-align: left">RKNPU2 闭源运行时（当前版本）</td></tr>
<tr><td style="text-align: left"><code>rknpu1/Linux/aarch64/librknn_api.so</code></td><td style="text-align: left">RKNPU1 旧版 API 库</td></tr>
<tr><td style="text-align: left"><code>rknpu2/include/rknn_api.h</code></td><td style="text-align: left">推理 API 头文件（805 行）</td></tr>
<tr><td style="text-align: left"><code>rknpu2/include/rknn_matmul_api.h</code></td><td style="text-align: left">Matmul API 头文件（544 行）</td></tr>
<tr><td style="text-align: left"><code>rknpu2/include/rknn_custom_op.h</code></td><td style="text-align: left">自定义算子 API 头文件（145 行）</td></tr>
</tbody></table>
</div>
<h2 id="文档结构-1"><a class="header" href="#文档结构-1">文档结构</a></h2>
<ul>
<li><strong><a href="documents/rknnlibso/./rknn-api.html">推理 API 参考</a></strong> — <code>rknn_api.h</code> 全部函数签名与逆向还原</li>
<li><strong><a href="documents/rknnlibso/./rknn-matmul.html">矩阵乘法 API</a></strong> — <code>rknn_matmul_api.h</code> 与 Native Layout 规范</li>
<li><strong><a href="documents/rknnlibso/./custom-op.html">自定义算子 API</a></strong> — <code>rknn_custom_op.h</code> 回调机制</li>
<li><strong><a href="documents/rknnlibso/./lifecycle.html">模型推理全链条</a></strong> — 从加载到运行到结束的完整逻辑链条</li>
<li><strong><a href="documents/rknnlibso/./memory.html">内存管理与零拷贝</a></strong> — 闭源库的内存分配策略</li>
<li><strong><a href="documents/rknnlibso/./internals.html">闭源库内部机制</a></strong> — 命令流生成、Task 构造、多核切分</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="推理-api-参考rknn_apih"><a class="header" href="#推理-api-参考rknn_apih">推理 API 参考（rknn_api.h）</a></h1>
<blockquote>
<p>来源：<code>test/starrynpu/demo/yolov8/3rdparty/rknpu2/include/rknn_api.h</code>
以下资料均来着StarryOS或社区收集。大多数暂未经过验证！。</p>
</blockquote>
<hr />
<h2 id="一类型定义"><a class="header" href="#一类型定义">一、类型定义</a></h2>
<h3 id="11-上下文句柄"><a class="header" href="#11-上下文句柄">1.1 上下文句柄</a></h3>
<pre><code class="language-c">#ifdef __arm__
typedef uint32_t rknn_context;
#else
typedef uint64_t rknn_context;
</code></pre>
<p>所有 API 围绕 <code>rknn_context</code> 句柄操作，内部指向闭源库维护的不透明状态。</p>
<h3 id="12-错误码"><a class="header" href="#12-错误码">1.2 错误码</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">常量</th><th style="text-align: left">值</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>RKNN_SUCC</code></td><td style="text-align: left">0</td><td style="text-align: left">成功</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_FAIL</code></td><td style="text-align: left">-1</td><td style="text-align: left">通用失败</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_TIMEOUT</code></td><td style="text-align: left">-2</td><td style="text-align: left">执行超时</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_DEVICE_UNAVAILABLE</code></td><td style="text-align: left">-3</td><td style="text-align: left">设备不可用</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_MALLOC_FAIL</code></td><td style="text-align: left">-4</td><td style="text-align: left">内存分配失败</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_PARAM_INVALID</code></td><td style="text-align: left">-5</td><td style="text-align: left">参数无效</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_MODEL_INVALID</code></td><td style="text-align: left">-6</td><td style="text-align: left">模型无效</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_CTX_INVALID</code></td><td style="text-align: left">-7</td><td style="text-align: left">上下文无效</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_INPUT_INVALID</code></td><td style="text-align: left">-8</td><td style="text-align: left">输入无效</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_OUTPUT_INVALID</code></td><td style="text-align: left">-9</td><td style="text-align: left">输出无效</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_DEVICE_UNMATCH</code></td><td style="text-align: left">-10</td><td style="text-align: left">设备不匹配（需更新 SDK/驱动）</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_INCOMPATILE_PRE_COMPILE_MODEL</code></td><td style="text-align: left">-11</td><td style="text-align: left">预编译模型不兼容</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_INCOMPATILE_OPTIMIZATION_LEVEL_VERSION</code></td><td style="text-align: left">-12</td><td style="text-align: left">优化级别版本不兼容</td></tr>
<tr><td style="text-align: left"><code>RKNN_ERR_TARGET_PLATFORM_UNMATCH</code></td><td style="text-align: left">-13</td><td style="text-align: left">目标平台不匹配</td></tr>
</tbody></table>
</div>
<h3 id="13-张量类型"><a class="header" href="#13-张量类型">1.3 张量类型</a></h3>
<pre><code class="language-c">typedef enum _rknn_tensor_type {
    RKNN_TENSOR_FLOAT32 = 0,
    RKNN_TENSOR_FLOAT16,      // 1
    RKNN_TENSOR_INT8,         // 2
    RKNN_TENSOR_UINT8,        // 3
    RKNN_TENSOR_INT16,        // 4
    RKNN_TENSOR_UINT16,       // 5
    RKNN_TENSOR_INT32,        // 6
    RKNN_TENSOR_UINT32,       // 7
    RKNN_TENSOR_INT64,        // 8
    RKNN_TENSOR_BOOL,         // 9
    RKNN_TENSOR_INT4,         // 10
    RKNN_TENSOR_BFLOAT16,     // 11
} rknn_tensor_type;
</code></pre>
<h3 id="14-量化类型"><a class="header" href="#14-量化类型">1.4 量化类型</a></h3>
<pre><code class="language-c">typedef enum _rknn_tensor_qnt_type {
    RKNN_TENSOR_QNT_NONE = 0,              // 无量化
    RKNN_TENSOR_QNT_DFP,                   // 动态定点（fractional length）
    RKNN_TENSOR_QNT_AFFINE_ASYMMETRIC,     // 非对称仿射（zero_point + scale）
} rknn_tensor_qnt_type;
</code></pre>
<h3 id="15-数据格式"><a class="header" href="#15-数据格式">1.5 数据格式</a></h3>
<pre><code class="language-c">typedef enum _rknn_tensor_format {
    RKNN_TENSOR_NCHW = 0,
    RKNN_TENSOR_NHWC,
    RKNN_TENSOR_NC1HWC2,    // NPU 原生格式
    RKNN_TENSOR_UNDEFINED,
} rknn_tensor_format;
</code></pre>
<h3 id="16-核心掩码"><a class="header" href="#16-核心掩码">1.6 核心掩码</a></h3>
<pre><code class="language-c">typedef enum _rknn_core_mask {
    RKNN_NPU_CORE_AUTO   = 0,       // 自动选择
    RKNN_NPU_CORE_0      = 1,       // 核心 0
    RKNN_NPU_CORE_1      = 2,       // 核心 1
    RKNN_NPU_CORE_2      = 4,       // 核心 2
    RKNN_NPU_CORE_0_1    = 3,       // 核心 0+1 联合
    RKNN_NPU_CORE_0_1_2  = 7,       // 三核联合
    RKNN_NPU_CORE_ALL    = 0xffff,  // 平台自动选择多核
} rknn_core_mask;
</code></pre>
<h3 id="17-初始化标志"><a class="header" href="#17-初始化标志">1.7 初始化标志</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">标志</th><th style="text-align: left">值</th><th style="text-align: left">说明</th><th style="text-align: left">逆向推断的内部行为</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>RKNN_FLAG_PRIOR_HIGH</code></td><td style="text-align: left">0x0</td><td style="text-align: left">高优先级（默认）</td><td style="text-align: left">设置 <code>nice -19</code></td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_PRIOR_MEDIUM</code></td><td style="text-align: left">0x1</td><td style="text-align: left">中优先级</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_PRIOR_LOW</code></td><td style="text-align: left">0x2</td><td style="text-align: left">低优先级</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_ASYNC_MASK</code></td><td style="text-align: left">0x4</td><td style="text-align: left">异步模式</td><td style="text-align: left"><code>rknn_outputs_get</code> 返回上一帧结果</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_COLLECT_PERF_MASK</code></td><td style="text-align: left">0x8</td><td style="text-align: left">性能采集</td><td style="text-align: left">启用逐层计时，降低帧率</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_MEM_ALLOC_OUTSIDE</code></td><td style="text-align: left">0x10</td><td style="text-align: left">外部内存分配</td><td style="text-align: left">用户负责分配 weight/internal/IO 内存</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_SHARE_WEIGHT_MEM</code></td><td style="text-align: left">0x20</td><td style="text-align: left">权重共享</td><td style="text-align: left">多上下文共享同一权重内存</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_FENCE_IN_OUTSIDE</code></td><td style="text-align: left">0x40</td><td style="text-align: left">外部输入 fence</td><td style="text-align: left">传入 DMA fence fd</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_FENCE_OUT_OUTSIDE</code></td><td style="text-align: left">0x80</td><td style="text-align: left">外部输出 fence</td><td style="text-align: left">获取 DMA fence fd</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_COLLECT_MODEL_INFO_ONLY</code></td><td style="text-align: left">0x100</td><td style="text-align: left">仅采集模型信息</td><td style="text-align: left">不实际加载，仅查询 weight/internal 大小</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_INTERNAL_ALLOC_OUTSIDE</code></td><td style="text-align: left">0x200</td><td style="text-align: left">外部分配内部内存</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_EXECUTE_FALLBACK_PRIOR_DEVICE_GPU</code></td><td style="text-align: left">0x400</td><td style="text-align: left">GPU 回退</td><td style="text-align: left">NPU 不支持的算子回退 GPU（OpenCL）</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_ENABLE_SRAM</code></td><td style="text-align: left">0x800</td><td style="text-align: left">启用 SRAM</td><td style="text-align: left">尝试在 SRAM 分配缓冲</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_SHARE_SRAM</code></td><td style="text-align: left">0x1000</td><td style="text-align: left">共享 SRAM</td><td style="text-align: left">多上下文共享 SRAM</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_DISABLE_PROC_HIGH_PRIORITY</code></td><td style="text-align: left">0x2000</td><td style="text-align: left">禁用高优先级</td><td style="text-align: left">不设置 <code>nice -19</code></td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_DISABLE_FLUSH_INPUT_MEM_CACHE</code></td><td style="text-align: left">0x4000</td><td style="text-align: left">禁用输入 cache flush</td><td style="text-align: left">用户自行保证 cache 一致性</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_DISABLE_FLUSH_OUTPUT_MEM_CACHE</code></td><td style="text-align: left">0x8000</td><td style="text-align: left">禁用输出 cache flush</td><td style="text-align: left">输出由 GPU/RGA 消费时使用</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_MODEL_BUFFER_ZERO_COPY</code></td><td style="text-align: left">0x10000</td><td style="text-align: left">模型缓冲零拷贝</td><td style="text-align: left">模型数据由 NPU 直接访问</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="二核心结构体"><a class="header" href="#二核心结构体">二、核心结构体</a></h2>
<h3 id="21-张量属性-rknn_tensor_attr"><a class="header" href="#21-张量属性-rknn_tensor_attr">2.1 张量属性 <code>rknn_tensor_attr</code></a></h3>
<pre><code class="language-c">typedef struct _rknn_tensor_attr {
    uint32_t index;                        // 输入/输出索引
    uint32_t n_dims;                       // 维度数
    uint32_t dims[RKNN_MAX_DIMS];          // 维度数组（最多 16 维）
    char     name[RKNN_MAX_NAME_LEN];      // 张量名（最长 256）
    uint32_t n_elems;                      // 元素总数
    uint32_t size;                         // 字节大小
    rknn_tensor_format fmt;                // 数据格式（NCHW/NHWC/NC1HWC2）
    rknn_tensor_type   type;               // 数据类型
    rknn_tensor_qnt_type qnt_type;         // 量化类型
    int8_t   fl;                           // DFP 小数位长度
    int32_t  zp;                           // 仿射量化零点
    float    scale;                        // 仿射量化缩放因子
    uint32_t w_stride;                     // 宽度方向步长（只读）
    uint32_t size_with_stride;             // 含步长的字节大小
    uint8_t  pass_through;                 // 直通模式标志
    uint32_t h_stride;                     // 高度方向步长（只写）
} rknn_tensor_attr;
</code></pre>
<h3 id="22-张量内存-rknn_tensor_mem"><a class="header" href="#22-张量内存-rknn_tensor_mem">2.2 张量内存 <code>rknn_tensor_mem</code></a></h3>
<pre><code class="language-c">typedef struct _rknn_tensor_memory {
    void*    virt_addr;     // 虚拟地址
    uint64_t phys_addr;     // 物理地址
    int32_t  fd;            // DMA buffer fd
    int32_t  offset;        // 内存偏移
    uint32_t size;          // 缓冲大小
    uint32_t flags;         // 标志
    void*    priv_data;     // 私有数据（闭源库内部使用）
} rknn_tensor_mem;
</code></pre>
<p><strong>逆向推断</strong>：<code>priv_data</code> 内部指向闭源库维护的 <code>rknpu_mem_create</code> 返回的 <code>obj_addr</code>，用于后续 <code>mem_destroy</code> 和 <code>mem_sync</code> 操作。</p>
<h3 id="23-查询命令-rknn_query_cmd"><a class="header" href="#23-查询命令-rknn_query_cmd">2.3 查询命令 <code>rknn_query_cmd</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">值</th><th style="text-align: left">返回结构体</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>RKNN_QUERY_IN_OUT_NUM</code></td><td style="text-align: left">0</td><td style="text-align: left"><code>rknn_input_output_num</code></td><td style="text-align: left">输入/输出数量</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_INPUT_ATTR</code></td><td style="text-align: left">1</td><td style="text-align: left"><code>rknn_tensor_attr</code></td><td style="text-align: left">输入张量属性</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_OUTPUT_ATTR</code></td><td style="text-align: left">2</td><td style="text-align: left"><code>rknn_tensor_attr</code></td><td style="text-align: left">输出张量属性</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_PERF_DETAIL</code></td><td style="text-align: left">3</td><td style="text-align: left"><code>rknn_perf_detail</code></td><td style="text-align: left">逐层性能（需 PERF_MASK）</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_PERF_RUN</code></td><td style="text-align: left">4</td><td style="text-align: left"><code>rknn_perf_run</code></td><td style="text-align: left">推理总耗时</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_SDK_VERSION</code></td><td style="text-align: left">5</td><td style="text-align: left"><code>rknn_sdk_version</code></td><td style="text-align: left">SDK/驱动版本</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_MEM_SIZE</code></td><td style="text-align: left">6</td><td style="text-align: left"><code>rknn_mem_size</code></td><td style="text-align: left">权重/内部内存大小</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_CUSTOM_STRING</code></td><td style="text-align: left">7</td><td style="text-align: left"><code>rknn_custom_string</code></td><td style="text-align: left">自定义字符串</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_NATIVE_INPUT_ATTR</code></td><td style="text-align: left">8</td><td style="text-align: left"><code>rknn_tensor_attr</code></td><td style="text-align: left">原生输入属性（NC1HWC2）</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_NATIVE_OUTPUT_ATTR</code></td><td style="text-align: left">9</td><td style="text-align: left"><code>rknn_tensor_attr</code></td><td style="text-align: left">原生输出属性</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_DEVICE_MEM_INFO</code></td><td style="text-align: left">12</td><td style="text-align: left">—</td><td style="text-align: left">设备内存信息</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_INPUT_DYNAMIC_RANGE</code></td><td style="text-align: left">13</td><td style="text-align: left"><code>rknn_input_range</code></td><td style="text-align: left">动态 shape 范围</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_CURRENT_INPUT_ATTR</code></td><td style="text-align: left">14</td><td style="text-align: left"><code>rknn_tensor_attr</code></td><td style="text-align: left">当前输入 shape（动态模型）</td></tr>
<tr><td style="text-align: left"><code>RKNN_QUERY_CURRENT_OUTPUT_ATTR</code></td><td style="text-align: left">15</td><td style="text-align: left"><code>rknn_tensor_attr</code></td><td style="text-align: left">当前输出 shape（动态模型）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="三函数签名与逆向还原"><a class="header" href="#三函数签名与逆向还原">三、函数签名与逆向还原</a></h2>
<h3 id="31-生命周期管理"><a class="header" href="#31-生命周期管理">3.1 生命周期管理</a></h3>
<h4 id="rknn_init"><a class="header" href="#rknn_init"><code>rknn_init</code></a></h4>
<pre><code class="language-c">int rknn_init(rknn_context* context, void* model, uint32_t size, uint32_t flag, rknn_init_extend* extend);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>context</code></td><td style="text-align: left">[out] 上下文句柄指针</td></tr>
<tr><td style="text-align: left"><code>model</code></td><td style="text-align: left"><code>size &gt; 0</code> 时为模型数据指针；<code>size = 0</code> 时为模型文件路径</td></tr>
<tr><td style="text-align: left"><code>size</code></td><td style="text-align: left">模型数据大小（0 表示从文件加载）</td></tr>
<tr><td style="text-align: left"><code>flag</code></td><td style="text-align: left">初始化标志组合（见 1.7）</td></tr>
<tr><td style="text-align: left"><code>extend</code></td><td style="text-align: left">扩展信息（可选，含 <code>real_model_offset</code>、<code>model_buffer_fd</code> 等）</td></tr>
</tbody></table>
</div>
<p><strong>逆向还原的内部流程</strong>：</p>
<pre><code>rknn_init()
├── 1. 打开 /dev/dri/card* 或 /dev/rknpu（获取 fd）
├── 2. ioctl(ACTION, RKNPU_GET_HW_VERSION) → 检查硬件版本
├── 3. 解析 .rknn 模型文件头
│   ├── 提取网络拓扑（层数、连接关系）
│   ├── 提取权重数据
│   └── 提取预编译命令流（如果是 pre-compile 模型）
├── 4. ioctl(MEM_CREATE) × N → 分配权重/内部/IO 内存
│   ├── 权重内存（RKNPU_MEM_KERNEL_MAPPING）
│   ├── 内部中间缓冲
│   └── 命令流缓冲（regcmd）
├── 5. ioctl(MEM_MAP) + mmap() → 映射到用户空间
├── 6. 将权重数据拷贝到 DMA 内存（转换为 native layout）
├── 7. 编译模型 → 生成寄存器命令流
│   ├── 为每层生成 NPUOP 指令序列
│   ├── 计算 CBUF bank 分配
│   └── 生成 Task 数组
├── 8. 如果 flag &amp; RKNN_FLAG_PRIOR_HIGH → ioctl(ACTION, RKNPU_SET_PROC_NICE)
└── 9. 返回 context 句柄
</code></pre>
<h4 id="rknn_destroy"><a class="header" href="#rknn_destroy"><code>rknn_destroy</code></a></h4>
<pre><code class="language-c">int rknn_destroy(rknn_context context);
</code></pre>
<p><strong>逆向还原</strong>：</p>
<pre><code>rknn_destroy()
├── 1. 释放所有 Task 数组内存
├── 2. munmap() + ioctl(MEM_DESTROY) × N → 释放所有 DMA 内存
├── 3. close(drm_fd)
└── 4. 释放上下文结构体
</code></pre>
<h4 id="rknn_dup_context"><a class="header" href="#rknn_dup_context"><code>rknn_dup_context</code></a></h4>
<pre><code class="language-c">int rknn_dup_context(rknn_context* context_in, rknn_context* context_out);
</code></pre>
<p>复制上下文，新上下文与原上下文共享权重内存（<code>RKNN_FLAG_SHARE_WEIGHT_MEM</code> 语义）。</p>
<hr />
<h3 id="32-推理流程"><a class="header" href="#32-推理流程">3.2 推理流程</a></h3>
<h4 id="rknn_inputs_set"><a class="header" href="#rknn_inputs_set"><code>rknn_inputs_set</code></a></h4>
<pre><code class="language-c">int rknn_inputs_set(rknn_context context, uint32_t n_inputs, rknn_input inputs[]);
</code></pre>
<p><strong>逆向还原</strong>：</p>
<pre><code>rknn_inputs_set()
├── 1. 遍历 inputs[]
│   ├── 如果 pass_through == TRUE → 直接拷贝到输入 DMA 内存
│   └── 如果 pass_through == FALSE →
│       ├── 格式转换（NHWC → NCHW 或 NC1HWC2）
│       ├── 类型转换（FP32 → INT8/FP16，应用 scale/zp）
│       └── 拷贝到输入 DMA 内存
└── 2. ioctl(MEM_SYNC, SYNC_TO_DEVICE) → flush cache
</code></pre>
<h4 id="rknn_run"><a class="header" href="#rknn_run"><code>rknn_run</code></a></h4>
<pre><code class="language-c">int rknn_run(rknn_context context, rknn_run_extend* extend);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>extend-&gt;frame_id</code></td><td style="text-align: left">[out] 当前帧 ID</td></tr>
<tr><td style="text-align: left"><code>extend-&gt;non_block</code></td><td style="text-align: left">0=阻塞，1=非阻塞</td></tr>
<tr><td style="text-align: left"><code>extend-&gt;timeout_ms</code></td><td style="text-align: left">阻塞模式超时（毫秒）</td></tr>
<tr><td style="text-align: left"><code>extend-&gt;fence_fd</code></td><td style="text-align: left">外部 fence fd</td></tr>
</tbody></table>
</div>
<p><strong>逆向还原</strong>（核心路径）：</p>
<pre><code>rknn_run()
├── 1. 构造 rknpu_submit 结构体
│   ├── flags = RKNPU_JOB_PC | RKNPU_JOB_BLOCK（或 NONBLOCK）| RKNPU_JOB_PINGPONG
│   ├── task_obj_addr = tasks DMA 对象地址
│   ├── core_mask = 根据 rknn_set_core_mask() 设置
│   ├── subcore_task[] = 根据多核切分策略填充
│   └── timeout = extend-&gt;timeout_ms 或默认值
├── 2. ioctl(DRM_IOCTL_RKNPU_SUBMIT, &amp;submit)
│   └── 内核驱动：
│       ├── 分配 job → 调度到核心
│       ├── 写 PC 寄存器（base_addr, amount, task_control, op_enable）
│       ├── 等待中断
│       └── 写回 task[].int_status
└── 3. 如果阻塞模式 → 等待 ioctl 返回
    如果非阻塞 → 立即返回，后续 rknn_wait() 或 rknn_outputs_get() 等待
</code></pre>
<h4 id="rknn_wait"><a class="header" href="#rknn_wait"><code>rknn_wait</code></a></h4>
<pre><code class="language-c">int rknn_wait(rknn_context context, rknn_run_extend* extend);
</code></pre>
<p>等待非阻塞推理完成。内部轮询或等待 fence 信号。</p>
<h4 id="rknn_outputs_get"><a class="header" href="#rknn_outputs_get"><code>rknn_outputs_get</code></a></h4>
<pre><code class="language-c">int rknn_outputs_get(rknn_context context, uint32_t n_outputs, rknn_output outputs[], rknn_output_extend* extend);
</code></pre>
<p><strong>逆向还原</strong>：</p>
<pre><code>rknn_outputs_get()
├── 1. 如果异步模式 → 返回上一帧结果（不等待当前帧）
├── 2. ioctl(MEM_SYNC, SYNC_FROM_DEVICE) → invalidate output cache
├── 3. 遍历 outputs[]
│   ├── 如果 want_float == TRUE →
│   │   ├── 反量化（INT8 → FP32，应用 scale/zp）
│   │   └── 格式转换（NC1HWC2 → NCHW/NHWC）
│   ├── 如果 is_prealloc == TRUE → 拷贝到用户提供的 buf
│   └── 如果 is_prealloc == FALSE → 分配 buf 并拷贝
└── 4. extend-&gt;frame_id = 当前帧 ID
</code></pre>
<h4 id="rknn_outputs_release"><a class="header" href="#rknn_outputs_release"><code>rknn_outputs_release</code></a></h4>
<pre><code class="language-c">int rknn_outputs_release(rknn_context context, uint32_t n_ouputs, rknn_output outputs[]);
</code></pre>
<p>释放 <code>rknn_outputs_get</code> 中 <code>is_prealloc == FALSE</code> 时分配的 buf。</p>
<hr />
<h3 id="33-查询接口"><a class="header" href="#33-查询接口">3.3 查询接口</a></h3>
<h4 id="rknn_query"><a class="header" href="#rknn_query"><code>rknn_query</code></a></h4>
<pre><code class="language-c">int rknn_query(rknn_context context, rknn_query_cmd cmd, void* info, uint32_t size);
</code></pre>
<p>通用查询接口。<code>info</code> 指向对应结构体，<code>size</code> 为结构体大小。</p>
<p><strong>关键查询结构体</strong>：</p>
<pre><code class="language-c">typedef struct _rknn_input_output_num {
    uint32_t n_input;
    uint32_t n_output;
} rknn_input_output_num;

typedef struct _rknn_perf_detail {
    char*    perf_data;      // 性能数据字符串（闭源库内部分配）
    uint64_t data_len;
} rknn_perf_detail;

typedef struct _rknn_perf_run {
    int64_t run_duration;    // 推理耗时（微秒）
} rknn_perf_run;

typedef struct _rknn_sdk_version {
    char api_version[256];
    char drv_version[256];
} rknn_sdk_version;

typedef struct _rknn_mem_size {
    uint32_t total_weight_size;
    uint32_t total_internal_size;
    uint64_t total_dma_allocated_size;
    uint32_t total_sram_size;
    uint32_t free_sram_size;
    uint32_t reserved[10];
} rknn_mem_size;
</code></pre>
<hr />
<h3 id="34-多核控制"><a class="header" href="#34-多核控制">3.4 多核控制</a></h3>
<h4 id="rknn_set_core_mask"><a class="header" href="#rknn_set_core_mask"><code>rknn_set_core_mask</code></a></h4>
<pre><code class="language-c">int rknn_set_core_mask(rknn_context context, rknn_core_mask core_mask);
</code></pre>
<p><strong>逆向推断</strong>：设置后续 <code>rknn_run</code> 提交时 <code>rknpu_submit.core_mask</code> 的值。对于联合核心模式（<code>CORE_0_1</code>、<code>CORE_0_1_2</code>），闭源库内部会将 Task 数组切分到 <code>subcore_task[]</code> 中。</p>
<h4 id="rknn_set_batch_core_num"><a class="header" href="#rknn_set_batch_core_num"><code>rknn_set_batch_core_num</code></a></h4>
<pre><code class="language-c">int rknn_set_batch_core_num(rknn_context context, int core_num);
</code></pre>
<p>设置批量推理时使用的核心数。</p>
<hr />
<h3 id="35-动态-shape"><a class="header" href="#35-动态-shape">3.5 动态 Shape</a></h3>
<h4 id="rknn_set_input_shapes"><a class="header" href="#rknn_set_input_shapes"><code>rknn_set_input_shapes</code></a></h4>
<pre><code class="language-c">int rknn_set_input_shapes(rknn_context ctx, uint32_t n_inputs, rknn_tensor_attr attr[]);
</code></pre>
<p>设置所有输入张量的 shape。仅对动态 shape 模型有效。调用后闭源库内部会重新编译命令流。</p>
<h4 id="rknn_set_input_shape已废弃"><a class="header" href="#rknn_set_input_shape已废弃"><code>rknn_set_input_shape</code>（已废弃）</a></h4>
<pre><code class="language-c">int rknn_set_input_shape(rknn_context ctx, rknn_tensor_attr* attr);
</code></pre>
<hr />
<h3 id="36-扩展结构体"><a class="header" href="#36-扩展结构体">3.6 扩展结构体</a></h3>
<h4 id="rknn_init_extend"><a class="header" href="#rknn_init_extend"><code>rknn_init_extend</code></a></h4>
<pre><code class="language-c">typedef struct _rknn_init_extend {
    rknn_context ctx;
    int32_t      real_model_offset;    // 模型文件内偏移（零拷贝模式）
    uint32_t     real_model_size;      // 模型实际大小
    int32_t      model_buffer_fd;      // 模型缓冲 fd
    uint32_t     model_buffer_flags;   // 模型缓冲标志
    uint8_t      reserved[112];
} rknn_init_extend;
</code></pre>
<h4 id="rknn_run_extend"><a class="header" href="#rknn_run_extend"><code>rknn_run_extend</code></a></h4>
<pre><code class="language-c">typedef struct _rknn_run_extend {
    uint64_t frame_id;       // [out] 帧 ID
    int32_t  non_block;      // 0=阻塞，1=非阻塞
    int32_t  timeout_ms;     // 超时（毫秒）
    int32_t  fence_fd;       // 外部 fence fd
} rknn_run_extend;
</code></pre>
<h4 id="rknn_output_extend"><a class="header" href="#rknn_output_extend"><code>rknn_output_extend</code></a></h4>
<pre><code class="language-c">typedef struct _rknn_output_extend {
    uint64_t frame_id;       // [out] 输出对应的帧 ID
} rknn_output_extend;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵乘法-apirknn_matmul_apih"><a class="header" href="#矩阵乘法-apirknn_matmul_apih">矩阵乘法 API（rknn_matmul_api.h）</a></h1>
<blockquote>
<p>来源：<code>test/starrynpu/demo/yolov8/3rdparty/rknpu2/include/rknn_matmul_api.h</code>（544 行）</p>
</blockquote>
<p>独立于模型推理的通用矩阵乘法加速接口。公式：<strong>C = A × B</strong>。</p>
<hr />
<h2 id="一支持的计算类型"><a class="header" href="#一支持的计算类型">一、支持的计算类型</a></h2>
<pre><code class="language-c">typedef enum _rknn_matmul_type {
    RKNN_FLOAT16_MM_FLOAT16_TO_FLOAT32 = 1,   // FP16 × FP16 → FP32
    RKNN_INT8_MM_INT8_TO_INT32         = 2,   // INT8 × INT8 → INT32
    RKNN_INT8_MM_INT8_TO_INT8          = 3,   // INT8 × INT8 → INT8
    RKNN_FLOAT16_MM_FLOAT16_TO_FLOAT16 = 4,   // FP16 × FP16 → FP16
    RKNN_FLOAT16_MM_INT8_TO_FLOAT32    = 5,   // FP16 × INT8 → FP32
    RKNN_FLOAT16_MM_INT8_TO_FLOAT16    = 6,   // FP16 × INT8 → FP16
    RKNN_FLOAT16_MM_INT4_TO_FLOAT32    = 7,   // FP16 × INT4 → FP32
    RKNN_FLOAT16_MM_INT4_TO_FLOAT16    = 8,   // FP16 × INT4 → FP16
    RKNN_INT8_MM_INT8_TO_FLOAT32       = 9,   // INT8 × INT8 → FP32
    RKNN_INT4_MM_INT4_TO_INT16         = 10,  // INT4 × INT4 → INT16
    RKNN_INT8_MM_INT4_TO_INT32         = 11,  // INT8 × INT4 → INT32
    RKNN_FLOAT16_MM_INT4_TO_BFLOAT16   = 12,  // FP16 × INT4 → BF16
    RKNN_INT8_MM_INT4_TO_FLOAT16       = 15,  // INT8 × INT4 → FP16
} rknn_matmul_type;
</code></pre>
<hr />
<h2 id="二对齐要求"><a class="header" href="#二对齐要求">二、对齐要求</a></h2>
<h3 id="rk3588--rk3576"><a class="header" href="#rk3588--rk3576">RK3588 / RK3576</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">精度</th><th style="text-align: left">K 对齐</th><th style="text-align: left">N 对齐</th><th style="text-align: left">K 最大值</th></tr></thead><tbody>
<tr><td style="text-align: left">INT4</td><td style="text-align: left">32 字节</td><td style="text-align: left">64 字节</td><td style="text-align: left">10240</td></tr>
<tr><td style="text-align: left">INT8</td><td style="text-align: left">32 字节</td><td style="text-align: left">32 字节</td><td style="text-align: left">10240</td></tr>
<tr><td style="text-align: left">FP16</td><td style="text-align: left">32 字节</td><td style="text-align: left">16 字节</td><td style="text-align: left">10240</td></tr>
</tbody></table>
</div>
<h3 id="rk3566--rk3568"><a class="header" href="#rk3566--rk3568">RK3566 / RK3568</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">精度</th><th style="text-align: left">K 对齐</th><th style="text-align: left">N 对齐</th></tr></thead><tbody>
<tr><td style="text-align: left">INT8</td><td style="text-align: left">32 字节</td><td style="text-align: left">16 字节</td></tr>
<tr><td style="text-align: left">FP16</td><td style="text-align: left">16 字节</td><td style="text-align: left">8 字节</td></tr>
</tbody></table>
</div>
<h3 id="rk3562"><a class="header" href="#rk3562">RK3562</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">精度</th><th style="text-align: left">K 对齐</th><th style="text-align: left">N 对齐</th></tr></thead><tbody>
<tr><td style="text-align: left">INT8</td><td style="text-align: left">32 字节</td><td style="text-align: left">16 字节</td></tr>
<tr><td style="text-align: left">FP16</td><td style="text-align: left">32 字节</td><td style="text-align: left">8 字节</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="三native-layout-规范"><a class="header" href="#三native-layout-规范">三、Native Layout 规范</a></h2>
<p>硬件要求输入/输出数据按特定分块格式排列。使用 native layout 可避免闭源库内部的格式转换开销。</p>
<h3 id="31-a-矩阵m--k"><a class="header" href="#31-a-矩阵m--k">3.1 A 矩阵（M × K）</a></h3>
<p><strong>Normal layout</strong>：<code>(M, K)</code> — 行主序。</p>
<p><strong>Native layout（RK3588/3576）</strong>：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">精度</th><th style="text-align: left">布局</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">INT4</td><td style="text-align: left"><code>(K/32, M, 32)</code></td><td style="text-align: left">每 32 个 K 元素为一组</td></tr>
<tr><td style="text-align: left">INT8</td><td style="text-align: left"><code>(K/16, M, 16)</code></td><td style="text-align: left">每 16 个 K 元素为一组</td></tr>
<tr><td style="text-align: left">FP16</td><td style="text-align: left"><code>(K/8, M, 8)</code></td><td style="text-align: left">每 8 个 K 元素为一组</td></tr>
</tbody></table>
</div>
<p>示例（FP16）：</p>
<pre><code>[K1M1, K2M1, ..., K8M1,
 K1M2, K2M2, ..., K8M2,
 ...
 K(k-7)Mm, K(k-6)Mm, ..., KkMm]
</code></pre>
<h3 id="32-b-矩阵k--n"><a class="header" href="#32-b-矩阵k--n">3.2 B 矩阵（K × N）</a></h3>
<p><strong>Normal layout</strong>：<code>(K, N)</code> — 行主序。</p>
<p><strong>Native layout（RK3588/3576）</strong>：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">精度</th><th style="text-align: left">布局</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">INT4</td><td style="text-align: left"><code>(N/64, K/32, 64, 32)</code></td><td style="text-align: left">64×32 分块</td></tr>
<tr><td style="text-align: left">INT8</td><td style="text-align: left"><code>(N/32, K/32, 32, 32)</code></td><td style="text-align: left">32×32 分块</td></tr>
<tr><td style="text-align: left">FP16</td><td style="text-align: left"><code>(N/16, K/32, 16, 32)</code></td><td style="text-align: left">16×32 分块</td></tr>
</tbody></table>
</div>
<p>示例（INT8, RK3588）：</p>
<pre><code>[K1N1,  K2N1,  ..., K32N1,
 K1N2,  K2N2,  ..., K32N2,
 ...
 K1N32, K2N32, ..., K32N32,    ← 第一个 32×32 块
 K33N1, K34N1, ..., K64N1,
 ...
 K(k-31)N32, ..., KkN32,      ← 第二个 K 块
 K1N33, K2N33, ..., K32N33,    ← 第二个 N 块
 ...]
</code></pre>
<h3 id="33-c-矩阵m--n"><a class="header" href="#33-c-矩阵m--n">3.3 C 矩阵（M × N）</a></h3>
<p><strong>Normal layout</strong>：<code>(M, N)</code> — 行主序。</p>
<p><strong>Native layout</strong>：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">平台</th><th style="text-align: left">精度</th><th style="text-align: left">布局</th></tr></thead><tbody>
<tr><td style="text-align: left">通用</td><td style="text-align: left">通用</td><td style="text-align: left"><code>(N/4, M, 4)</code></td></tr>
<tr><td style="text-align: left">RK3588</td><td style="text-align: left">INT4</td><td style="text-align: left"><code>(N/8, M, 8)</code></td></tr>
</tbody></table>
</div>
<h3 id="34-k-分段规则"><a class="header" href="#34-k-分段规则">3.4 K 分段规则</a></h3>
<p>当 K 超过硬件限制时，B 矩阵自动分段：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">平台</th><th style="text-align: left">分段阈值</th><th style="text-align: left">分段数</th></tr></thead><tbody>
<tr><td style="text-align: left">RK3588</td><td style="text-align: left">K &gt; 8192</td><td style="text-align: left"><code>T = ceil(K / 8192)</code></td></tr>
<tr><td style="text-align: left">RK3576</td><td style="text-align: left">K &gt; 4096</td><td style="text-align: left"><code>T = ceil(K / 4096)</code></td></tr>
</tbody></table>
</div>
<p>分段后每段独立按 native layout 排列。推荐使用 <code>rknn_B_normal_layout_to_native_layout()</code> 进行自动转换。</p>
<hr />
<h2 id="四函数签名"><a class="header" href="#四函数签名">四、函数签名</a></h2>
<h3 id="41-创建与销毁"><a class="header" href="#41-创建与销毁">4.1 创建与销毁</a></h3>
<h4 id="rknn_matmul_create"><a class="header" href="#rknn_matmul_create"><code>rknn_matmul_create</code></a></h4>
<pre><code class="language-c">int rknn_matmul_create(rknn_matmul_ctx* ctx, rknn_matmul_info* info, rknn_matmul_io_attr* io_attr);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ctx</code></td><td style="text-align: left">[out] matmul 上下文句柄</td></tr>
<tr><td style="text-align: left"><code>info</code></td><td style="text-align: left">[in] matmul 配置（M/K/N、类型、布局、量化）</td></tr>
<tr><td style="text-align: left"><code>io_attr</code></td><td style="text-align: left">[out] 输入/输出属性（含实际维度和大小）</td></tr>
</tbody></table>
</div>
<h4 id="rknn_matmul_create_dynamic_shape"><a class="header" href="#rknn_matmul_create_dynamic_shape"><code>rknn_matmul_create_dynamic_shape</code></a></h4>
<pre><code class="language-c">int rknn_matmul_create_dynamic_shape(rknn_matmul_ctx* ctx, rknn_matmul_info* info,
    int shape_num, rknn_matmul_shape dynamic_shapes[], rknn_matmul_io_attr io_attrs[]);
</code></pre>
<p>创建支持动态 M/K/N 的 matmul 上下文。<code>info.M/K/N</code> 无效，以 <code>dynamic_shapes[]</code> 为准。</p>
<h4 id="rknn_matmul_destroy"><a class="header" href="#rknn_matmul_destroy"><code>rknn_matmul_destroy</code></a></h4>
<pre><code class="language-c">int rknn_matmul_destroy(rknn_matmul_ctx ctx);
</code></pre>
<h3 id="42-io-绑定"><a class="header" href="#42-io-绑定">4.2 IO 绑定</a></h3>
<h4 id="rknn_matmul_set_io_mem"><a class="header" href="#rknn_matmul_set_io_mem"><code>rknn_matmul_set_io_mem</code></a></h4>
<pre><code class="language-c">int rknn_matmul_set_io_mem(rknn_matmul_ctx ctx, rknn_tensor_mem* mem, rknn_matmul_tensor_attr* attr);
</code></pre>
<p>绑定 A/B/C 矩阵的内存。<code>attr</code> 来自 <code>rknn_matmul_create</code> 返回的 <code>io_attr</code>。</p>
<h3 id="43-执行"><a class="header" href="#43-执行">4.3 执行</a></h3>
<h4 id="rknn_matmul_run"><a class="header" href="#rknn_matmul_run"><code>rknn_matmul_run</code></a></h4>
<pre><code class="language-c">int rknn_matmul_run(rknn_matmul_ctx ctx);
</code></pre>
<p>阻塞执行矩阵乘法。</p>
<p><strong>逆向推断的内部流程</strong>：</p>
<pre><code>rknn_matmul_run()
├── 1. 根据 M/K/N 和精度生成命令流
│   ├── 填充 CNA 描述符（卷积参数映射为 matmul）
│   ├── 填充 CORE 描述符
│   └── 填充 DPU 描述符（输出转换）
├── 2. 构造 rknpu_task 数组
│   ├── enable_mask = 0xd（CNA + CORE + DPU）
│   ├── int_mask = 0x300（DPU 完成中断）
│   └── regcmd_addr = 命令流 DMA 地址
├── 3. 构造 rknpu_submit
│   ├── flags = RKNPU_JOB_PC | RKNPU_JOB_BLOCK | RKNPU_JOB_PINGPONG
│   └── core_mask = 根据 rknn_matmul_set_core_mask() 设置
└── 4. ioctl(DRM_IOCTL_RKNPU_SUBMIT)
</code></pre>
<h3 id="44-核心控制"><a class="header" href="#44-核心控制">4.4 核心控制</a></h3>
<h4 id="rknn_matmul_set_core_mask"><a class="header" href="#rknn_matmul_set_core_mask"><code>rknn_matmul_set_core_mask</code></a></h4>
<pre><code class="language-c">int rknn_matmul_set_core_mask(rknn_matmul_ctx context, rknn_core_mask core_mask);
</code></pre>
<h3 id="45-量化参数"><a class="header" href="#45-量化参数">4.5 量化参数</a></h3>
<h4 id="rknn_matmul_set_quant_params"><a class="header" href="#rknn_matmul_set_quant_params"><code>rknn_matmul_set_quant_params</code></a></h4>
<pre><code class="language-c">int rknn_matmul_set_quant_params(rknn_matmul_ctx context, rknn_quant_params* params);
</code></pre>
<p>设置量化参数。仅支持 <code>INT8_MM_INT8_TO_INT8</code> 和 <code>INT8_MM_INT8_TO_INT32</code> 类型。</p>
<h4 id="rknn_matmul_get_quant_params"><a class="header" href="#rknn_matmul_get_quant_params"><code>rknn_matmul_get_quant_params</code></a></h4>
<pre><code class="language-c">int rknn_matmul_get_quant_params(rknn_matmul_ctx ctx, rknn_quant_params* params, float* scale);
</code></pre>
<h3 id="46-动态-shape"><a class="header" href="#46-动态-shape">4.6 动态 Shape</a></h3>
<h4 id="rknn_matmul_set_dynamic_shape"><a class="header" href="#rknn_matmul_set_dynamic_shape"><code>rknn_matmul_set_dynamic_shape</code></a></h4>
<pre><code class="language-c">int rknn_matmul_set_dynamic_shape(rknn_matmul_ctx ctx, rknn_matmul_shape* shape);
</code></pre>
<p>运行时切换 M/K/N（目前仅支持 M 动态）。</p>
<h3 id="47-布局转换"><a class="header" href="#47-布局转换">4.7 布局转换</a></h3>
<h4 id="rknn_b_normal_layout_to_native_layout"><a class="header" href="#rknn_b_normal_layout_to_native_layout"><code>rknn_B_normal_layout_to_native_layout</code></a></h4>
<pre><code class="language-c">int rknn_B_normal_layout_to_native_layout(void* B_input, void* B_output, int K, int N, rknn_matmul_info* info);
</code></pre>
<p>将 B 矩阵从 normal layout 转换为 native layout。处理 K 分段和平台差异。</p>
<hr />
<h2 id="五配置结构体"><a class="header" href="#五配置结构体">五、配置结构体</a></h2>
<h3 id="rknn_matmul_info"><a class="header" href="#rknn_matmul_info"><code>rknn_matmul_info</code></a></h3>
<pre><code class="language-c">typedef struct rknn_matmul_info_t {
    int32_t M;
    int32_t K;
    int32_t N;
    rknn_matmul_type type;       // 计算类型
    int16_t B_layout;            // 0=normal, 1=native
    int16_t B_quant_type;        // 0=per-layer, 1=per-channel, 2=per-group
    int16_t AC_layout;           // 0=normal, 1=native
    int16_t AC_quant_type;       // 仅支持 0
    int32_t iommu_domain_id;     // IOMMU 域 ID
    int16_t group_size;          // per-group 量化的组大小
    int8_t  reserved[34];
} rknn_matmul_info;
</code></pre>
<h3 id="rknn_quant_params"><a class="header" href="#rknn_quant_params"><code>rknn_quant_params</code></a></h3>
<pre><code class="language-c">typedef struct _rknn_quant_params {
    char     name[RKNN_MAX_NAME_LEN];
    float*   scale;              // 缩放因子数组
    int32_t  scale_len;
    int32_t* zp;                 // 零点数组
    int32_t  zp_len;
} rknn_quant_params;
</code></pre>
<hr />
<h2 id="六与裸-ioctl-demo-的对应关系"><a class="header" href="#六与裸-ioctl-demo-的对应关系">六、与裸 ioctl demo 的对应关系</a></h2>
<p><code>npu_benchmark</code> 和 <code>npu_llama</code> 中的手工 matmul 实现，本质上是 <code>rknn_matmul_run()</code> 内部逻辑的开源复刻：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">闭源 API</th><th style="text-align: left">裸 ioctl demo 对应</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>rknn_matmul_create()</code></td><td style="text-align: left"><code>gen_matmul_fp16()</code> / <code>gen_matmul_int8()</code> 生成命令流</td></tr>
<tr><td style="text-align: left"><code>rknn_matmul_set_io_mem()</code></td><td style="text-align: left"><code>mem_allocate()</code> + <code>weight_fp16()</code> / <code>feature_data()</code> 排列数据</td></tr>
<tr><td style="text-align: left"><code>rknn_matmul_run()</code></td><td style="text-align: left">填充 <code>rknpu_task</code> + <code>rknpu_submit</code> + <code>ioctl(SUBMIT)</code></td></tr>
<tr><td style="text-align: left"><code>rknn_matmul_destroy()</code></td><td style="text-align: left"><code>munmap()</code> + <code>mem_destroy()</code></td></tr>
<tr><td style="text-align: left">native layout</td><td style="text-align: left"><code>weight_fp16()</code> / <code>weight_int8()</code> / <code>feature_data()</code> 函数</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="自定义算子-apirknn_custom_oph"><a class="header" href="#自定义算子-apirknn_custom_oph">自定义算子 API（rknn_custom_op.h）</a></h1>
<blockquote>
<p>来源：<code>test/starrynpu/demo/yolov8/3rdparty/rknpu2/include/rknn_custom_op.h</code>（145 行）</p>
</blockquote>
<p>当模型中包含 NPU 不支持的算子时，闭源库提供自定义算子机制，允许用户注册 CPU 或 GPU（OpenCL）回调函数来实现这些算子。</p>
<hr />
<h2 id="一核心概念"><a class="header" href="#一核心概念">一、核心概念</a></h2>
<pre><code>模型推理流程中遇到不支持的算子：
    NPU 执行 layer 0~5
    → 自定义算子回调执行 layer 6（CPU/GPU）
    → NPU 继续执行 layer 7~N
</code></pre>
<p>闭源库在推理过程中自动调度：NPU 可执行的层在 NPU 上运行，不支持的层调用用户注册的回调。</p>
<hr />
<h2 id="二类型定义"><a class="header" href="#二类型定义">二、类型定义</a></h2>
<h3 id="21-执行后端"><a class="header" href="#21-执行后端">2.1 执行后端</a></h3>
<pre><code class="language-c">typedef enum _rknn_target_type {
    RKNN_TARGET_TYPE_CPU = 1,    // CPU 后端
    RKNN_TARGET_TYPE_GPU = 2,    // GPU 后端（OpenCL）
} rknn_target_type;
</code></pre>
<h3 id="22-gpu-上下文"><a class="header" href="#22-gpu-上下文">2.2 GPU 上下文</a></h3>
<pre><code class="language-c">typedef struct _rknn_gpu_op_context {
    void* cl_context;          // OpenCL context
    void* cl_command_queue;    // OpenCL command queue
    void* cl_kernel;           // OpenCL kernel
} rknn_gpu_op_context;
</code></pre>
<h3 id="23-算子上下文"><a class="header" href="#23-算子上下文">2.3 算子上下文</a></h3>
<pre><code class="language-c">typedef struct _rknn_custom_op_context {
    rknn_target_type               target;        // 后端类型
    rknn_custom_op_interal_context internal_ctx;   // 闭源库内部上下文
    rknn_gpu_op_context            gpu_ctx;        // GPU 上下文
    void*                          priv_data;      // 用户私有数据
} rknn_custom_op_context;
</code></pre>
<h3 id="24-算子张量"><a class="header" href="#24-算子张量">2.4 算子张量</a></h3>
<pre><code class="language-c">typedef struct _rknn_custom_op_tensor {
    rknn_tensor_attr attr;    // 张量属性（维度、类型、量化参数）
    rknn_tensor_mem  mem;     // 张量内存（虚拟地址、物理地址、fd）
} rknn_custom_op_tensor;
</code></pre>
<h3 id="25-算子属性"><a class="header" href="#25-算子属性">2.5 算子属性</a></h3>
<pre><code class="language-c">typedef struct _rknn_custom_op_attr {
    char             name[RKNN_MAX_NAME_LEN];   // 属性名
    rknn_tensor_type dtype;                      // 数据类型
    uint32_t         n_elems;                    // 元素数量
    void*            data;                       // 属性数据指针
} rknn_custom_op_attr;
</code></pre>
<hr />
<h2 id="三算子注册结构体"><a class="header" href="#三算子注册结构体">三、算子注册结构体</a></h2>
<pre><code class="language-c">typedef struct _rknn_custom_op {
    uint32_t         version;                         // 版本号
    rknn_target_type target;                          // CPU 或 GPU
    char             op_type[RKNN_MAX_NAME_LEN];      // 算子类型名

    // GPU（OpenCL）专用字段
    char     cl_kernel_name[RKNN_MAX_NAME_LEN];       // OpenCL kernel 名
    char*    cl_kernel_source;                         // kernel 源码或文件路径
    uint64_t cl_source_size;                           // 源码大小（0=文件路径）
    char     cl_build_options[RKNN_MAX_NAME_LEN];     // 编译选项

    // 回调函数
    int (*init)(rknn_custom_op_context* op_ctx,
                rknn_custom_op_tensor* inputs, uint32_t n_inputs,
                rknn_custom_op_tensor* outputs, uint32_t n_outputs);
                // [可选] 初始化回调

    int (*prepare)(rknn_custom_op_context* op_ctx,
                   rknn_custom_op_tensor* inputs, uint32_t n_inputs,
                   rknn_custom_op_tensor* outputs, uint32_t n_outputs);
                   // [可选] 准备回调

    int (*compute)(rknn_custom_op_context* op_ctx,
                   rknn_custom_op_tensor* inputs, uint32_t n_inputs,
                   rknn_custom_op_tensor* outputs, uint32_t n_outputs);
                   // [必须] 计算回调

    int (*compute_native)(rknn_custom_op_context* op_ctx,
                          rknn_custom_op_tensor* inputs, uint32_t n_inputs,
                          rknn_custom_op_tensor* outputs, uint32_t n_outputs);
                          // [可选] 原生属性计算回调（当前不支持）

    int (*destroy)(rknn_custom_op_context* op_ctx);
                   // [可选] 销毁回调
} rknn_custom_op;
</code></pre>
<p><strong>特殊返回值</strong>：<code>init</code> 回调返回 <code>RKNN_WARNING_SKIP_CUSTOM_OP_COMPUTE</code>（-14）时，如果该算子类型被 RKNN 内部支持，则使用内部实现而非自定义回调。</p>
<hr />
<h2 id="四函数签名-1"><a class="header" href="#四函数签名-1">四、函数签名</a></h2>
<h3 id="rknn_register_custom_ops"><a class="header" href="#rknn_register_custom_ops"><code>rknn_register_custom_ops</code></a></h3>
<pre><code class="language-c">int rknn_register_custom_ops(rknn_context ctx, rknn_custom_op* op, uint32_t custom_op_num);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ctx</code></td><td style="text-align: left">rknn 上下文（必须在 <code>rknn_init</code> 之后调用）</td></tr>
<tr><td style="text-align: left"><code>op</code></td><td style="text-align: left">自定义算子数组</td></tr>
<tr><td style="text-align: left"><code>custom_op_num</code></td><td style="text-align: left">数组长度</td></tr>
</tbody></table>
</div>
<p><strong>使用步骤</strong>：</p>
<ol>
<li>创建 <code>rknn_custom_op</code> 结构体数组</li>
<li>填写 <code>op_type</code>、<code>target</code>、回调函数</li>
<li>在 <code>rknn_init()</code> 之后调用 <code>rknn_register_custom_ops()</code></li>
</ol>
<h3 id="rknn_custom_op_get_op_attr"><a class="header" href="#rknn_custom_op_get_op_attr"><code>rknn_custom_op_get_op_attr</code></a></h3>
<pre><code class="language-c">void rknn_custom_op_get_op_attr(rknn_custom_op_context* op_ctx,
                                 const char* attr_name,
                                 rknn_custom_op_attr* op_attr);
</code></pre>
<p>在回调函数内部调用，获取模型中定义的算子属性（如 kernel_size、stride 等）。</p>
<hr />
<h2 id="五动态加载机制"><a class="header" href="#五动态加载机制">五、动态加载机制</a></h2>
<p>闭源库支持通过 <code>dlopen</code> 加载自定义算子 <code>.so</code>：</p>
<pre><code class="language-c">typedef rknn_custom_op* (*get_custom_op_func)();
</code></pre>
<p>自定义算子 <code>.so</code> 需导出 <code>get_custom_op_func</code> 类型的函数，返回 <code>rknn_custom_op</code> 指针。需使用 <code>RKNN_CUSTOM_OP_EXPORT</code>（<code>__attribute__((visibility("default")))</code>）标记导出函数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模型推理全链条分析"><a class="header" href="#模型推理全链条分析">模型推理全链条分析</a></h1>
<p>从加载 <code>.rknn</code> 模型到推理完成到资源释放的完整逻辑链条。</p>
<blockquote>
<p>逆向来源：闭源库头文件 <code>rknn_api.h</code>、开源内核驱动 <code>rknpu/</code>、裸 ioctl demo <code>npu_benchmark</code>/<code>npu_llama</code>、StarryOS Rust 驱动。</p>
</blockquote>
<hr />
<h2 id="一全链条总览"><a class="header" href="#一全链条总览">一、全链条总览</a></h2>
<pre><code>┌──────────────────────────────────────────────────────────────────┐
│ 阶段 1：初始化                                                    │
│   rknn_init()                                                    │
│   ├── 打开设备 → 检查硬件版本                                      │
│   ├── 解析 .rknn 模型                                             │
│   ├── 分配 DMA 内存（权重/内部/IO/命令流）                          │
│   ├── 权重转换 → native layout → 拷贝到 DMA 内存                   │
│   └── 编译模型 → 生成命令流 + Task 数组                             │
├──────────────────────────────────────────────────────────────────┤
│ 阶段 2：配置（可选）                                               │
│   rknn_set_core_mask()      → 选择 NPU 核心                      │
│   rknn_register_custom_ops() → 注册自定义算子                      │
│   rknn_set_input_shapes()   → 设置动态 shape                     │
├──────────────────────────────────────────────────────────────────┤
│ 阶段 3：推理循环（可重复执行）                                      │
│   rknn_inputs_set()  → 格式/类型转换 → 拷贝到 DMA → flush cache   │
│   rknn_run()         → 构造 submit → ioctl(SUBMIT) → 等待中断     │
│   rknn_outputs_get() → invalidate cache → 反量化 → 格式转换       │
│   rknn_outputs_release() → 释放输出缓冲                           │
├──────────────────────────────────────────────────────────────────┤
│ 阶段 4：销毁                                                      │
│   rknn_destroy()                                                 │
│   ├── 释放所有 DMA 内存                                           │
│   ├── 关闭设备 fd                                                 │
│   └── 释放上下文                                                  │
└──────────────────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="二阶段-1初始化rknn_init"><a class="header" href="#二阶段-1初始化rknn_init">二、阶段 1：初始化（<code>rknn_init</code>）</a></h2>
<h3 id="21-设备打开"><a class="header" href="#21-设备打开">2.1 设备打开</a></h3>
<pre><code>rknn_init()
└── open("/dev/dri/card0") 或 open("/dev/dri/renderD128")
    └── 获取 DRM fd
</code></pre>
<p><strong>逆向证据</strong>：<code>npu_interface.c</code> 中 <code>npu_open()</code> 遍历 <code>/dev/dri/card*</code>，用 <code>drmGetVersion()</code> 检查驱动名是否为 <code>"rknpu"</code>。</p>
<h3 id="22-硬件版本检查"><a class="header" href="#22-硬件版本检查">2.2 硬件版本检查</a></h3>
<pre><code class="language-c">struct rknpu_action action = { .flags = RKNPU_GET_HW_VERSION };
ioctl(fd, DRM_IOCTL_RKNPU_ACTION, &amp;action);
// action.value → 硬件版本号
</code></pre>
<p>闭源库据此选择对应的硬件配置（核心数、CBUF 大小、支持的精度等）。</p>
<h3 id="23-模型解析"><a class="header" href="#23-模型解析">2.3 模型解析</a></h3>
<p><code>.rknn</code> 是 Rockchip 私有的模型格式，包含：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">段</th><th style="text-align: left">内容</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">文件头</td><td style="text-align: left">魔数、版本、段表</td><td style="text-align: left">标识文件格式</td></tr>
<tr><td style="text-align: left">网络拓扑</td><td style="text-align: left">层定义、连接关系</td><td style="text-align: left">计算图描述</td></tr>
<tr><td style="text-align: left">权重数据</td><td style="text-align: left">量化后的权重</td><td style="text-align: left">可能已是 native layout</td></tr>
<tr><td style="text-align: left">预编译命令流</td><td style="text-align: left">寄存器命令序列</td><td style="text-align: left">pre-compile 模型专用</td></tr>
<tr><td style="text-align: left">量化参数</td><td style="text-align: left">scale/zp 表</td><td style="text-align: left">每层或每通道</td></tr>
<tr><td style="text-align: left">自定义字符串</td><td style="text-align: left">用户元数据</td><td style="text-align: left">可选</td></tr>
</tbody></table>
</div>
<p><strong>模型格式完全闭源</strong>，无公开文档。</p>
<h3 id="24-内存分配"><a class="header" href="#24-内存分配">2.4 内存分配</a></h3>
<p>闭源库通过 ioctl 分配多块 DMA 内存：</p>
<pre><code>ioctl(MEM_CREATE, { size, flags }) → { handle, obj_addr, dma_addr }
ioctl(MEM_MAP, { handle }) → { offset }
mmap(fd, offset) → virt_addr
</code></pre>
<p>分配的内存块：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">用途</th><th style="text-align: left">flags</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">权重内存</td><td style="text-align: left"><code>RKNPU_MEM_KERNEL_MAPPING</code></td><td style="text-align: left">内核态也需要访问</td></tr>
<tr><td style="text-align: left">内部中间缓冲</td><td style="text-align: left">0 或 <code>RKNPU_MEM_CACHEABLE</code></td><td style="text-align: left">层间数据传递</td></tr>
<tr><td style="text-align: left">输入缓冲</td><td style="text-align: left">0</td><td style="text-align: left">用户写入输入数据</td></tr>
<tr><td style="text-align: left">输出缓冲</td><td style="text-align: left">0</td><td style="text-align: left">硬件写入输出数据</td></tr>
<tr><td style="text-align: left">命令流缓冲（regcmd）</td><td style="text-align: left">0</td><td style="text-align: left">存放 NPUOP 指令序列</td></tr>
<tr><td style="text-align: left">Task 数组</td><td style="text-align: left"><code>RKNPU_MEM_KERNEL_MAPPING</code></td><td style="text-align: left">内核驱动直接读取</td></tr>
</tbody></table>
</div>
<p><strong>逆向证据</strong>：<code>llama0.c</code> 中 <code>build_transformer()</code> 分配了 regcmd（1024 字节）和 tasks（1024 字节，带 <code>RKNPU_MEM_KERNEL_MAPPING</code>）。</p>
<h3 id="25-权重转换"><a class="header" href="#25-权重转换">2.5 权重转换</a></h3>
<p>闭源库将模型权重从存储格式转换为 NPU native layout：</p>
<pre><code>原始权重（行主序）
    ↓ 量化（如果需要）
量化权重（INT8/INT4）
    ↓ 重排列
Native Layout（按硬件分块要求）
    ↓ memcpy
DMA 内存
</code></pre>
<p><strong>逆向证据</strong>：<code>llama0.c</code> 中 <code>create_weight_cache()</code> 将 FP32 权重转为 FP16 并用 <code>feature_data()</code> 函数重排列到 native layout。</p>
<h3 id="26-命令流编译"><a class="header" href="#26-命令流编译">2.6 命令流编译</a></h3>
<p>对于非预编译模型，闭源库为每层生成寄存器命令流：</p>
<pre><code>网络层描述
    ↓ 参数计算
CNA/CORE/DPU 描述符
    ↓ NPUOP 编码
64-bit 命令序列（regcmd buffer）
    ↓
Task 数组（每个 task 指向一段命令流）
</code></pre>
<p>每条命令格式：<code>NPUOP(模块ID, 寄存器值, 寄存器偏移)</code></p>
<pre><code class="language-c">// 编码：[15:0]=寄存器偏移, [47:16]=寄存器值, [63:48]=模块ID
#define NPUOP(op, value, reg) \
    (((uint64_t)(op &amp; 0xffff)) &lt;&lt; 48) | \
    (((uint64_t)(value &amp; 0xffffffff)) &lt;&lt; 16) | \
    (uint64_t)(reg &amp; 0xffff)
</code></pre>
<p><strong>逆向证据</strong>：<code>npu_matmul.c</code> 中 <code>gen_matmul_task()</code> 生成 108 条 NPUOP 指令，覆盖 CNA（30 条）、CORE（6 条）、DPU（70+ 条）寄存器。</p>
<hr />
<h2 id="三阶段-2配置"><a class="header" href="#三阶段-2配置">三、阶段 2：配置</a></h2>
<h3 id="31-核心选择"><a class="header" href="#31-核心选择">3.1 核心选择</a></h3>
<pre><code class="language-c">rknn_set_core_mask(ctx, RKNN_NPU_CORE_0_1_2);
</code></pre>
<p>影响后续 <code>rknn_run()</code> 中 <code>rknpu_submit.core_mask</code> 和 <code>subcore_task[]</code> 的填充。</p>
<p><strong>多核切分逻辑</strong>（闭源库内部）：</p>
<ul>
<li>单核模式：所有 task 在一个核心上顺序执行</li>
<li>双核/三核模式：将 task 数组按层切分，分配到不同核心的 <code>subcore_task[]</code></li>
</ul>
<h3 id="32-自定义算子注册"><a class="header" href="#32-自定义算子注册">3.2 自定义算子注册</a></h3>
<pre><code class="language-c">rknn_custom_op ops[1] = { ... };
rknn_register_custom_ops(ctx, ops, 1);
</code></pre>
<p>详见 <a href="documents/rknnlibso/./custom-op.html">自定义算子 API</a>。</p>
<hr />
<h2 id="四阶段-3推理循环"><a class="header" href="#四阶段-3推理循环">四、阶段 3：推理循环</a></h2>
<h3 id="41-设置输入rknn_inputs_set"><a class="header" href="#41-设置输入rknn_inputs_set">4.1 设置输入（<code>rknn_inputs_set</code>）</a></h3>
<pre><code class="language-c">rknn_input inputs[1];
inputs[0].index = 0;
inputs[0].buf = image_data;
inputs[0].size = 640 * 640 * 3;
inputs[0].type = RKNN_TENSOR_UINT8;
inputs[0].fmt = RKNN_TENSOR_NHWC;
inputs[0].pass_through = 0;

rknn_inputs_set(ctx, 1, inputs);
</code></pre>
<p><strong>闭源库内部流程</strong>：</p>
<pre><code>用户数据（NHWC, UINT8）
    ↓ pass_through == FALSE
格式转换: NHWC → NC1HWC2（NPU 原生格式）
    ↓
类型转换: UINT8 → INT8（应用 zp 偏移）
    ↓
memcpy → 输入 DMA 缓冲
    ↓
ioctl(MEM_SYNC, SYNC_TO_DEVICE)  // flush CPU cache → 设备可见
</code></pre>
<p>如果 <code>pass_through == TRUE</code>，跳过格式/类型转换，直接拷贝。</p>
<h3 id="42-执行推理rknn_run"><a class="header" href="#42-执行推理rknn_run">4.2 执行推理（<code>rknn_run</code>）</a></h3>
<pre><code class="language-c">rknn_run_extend extend = { .non_block = 0, .timeout_ms = 5000 };
rknn_run(ctx, &amp;extend);
</code></pre>
<h4 id="421-闭源库侧构造-rknpu_submit"><a class="header" href="#421-闭源库侧构造-rknpu_submit">4.2.1 闭源库侧：构造 <code>rknpu_submit</code></a></h4>
<pre><code>rknn_run()
├── 构造 rknpu_submit
│   ├── flags:
│   │   ├── RKNPU_JOB_PC        (1)  ← PC 模式
│   │   ├── RKNPU_JOB_BLOCK     (0)  ← 阻塞（或 NONBLOCK）
│   │   └── RKNPU_JOB_PINGPONG  (4)  ← 乒乓模式
│   ├── timeout = 5000
│   ├── task_start = 0
│   ├── task_number = N（总 task 数）
│   ├── task_obj_addr = tasks DMA 对象地址
│   ├── core_mask = 0x1（单核）或 0x7（三核）
│   └── subcore_task[]:
│       ├── [0] = { start=0, number=N }     ← 核心 0 的 task 范围
│       ├── [1] = { start=N, number=0 }     ← 核心 1（如果启用）
│       └── [2] = { start=N, number=0 }     ← 核心 2（如果启用）
└── ioctl(DRM_IOCTL_RKNPU_SUBMIT, &amp;submit)
</code></pre>
<h4 id="422-内核驱动侧任务提交完整时序"><a class="header" href="#422-内核驱动侧任务提交完整时序">4.2.2 内核驱动侧：任务提交完整时序</a></h4>
<pre><code class="language-mermaid">sequenceDiagram
    participant U as 用户态 (librknnrt.so)
    participant S as sys_ioctl
    participant D as DeviceOps::ioctl
    participant I as submit_ioctrl()
    participant O as submit_one(idx)
    participant P as submit_pc()
    participant H as NPU 硬件

    U-&gt;&gt;S: ioctl(fd, DRM_IOCTL_RKNPU_SUBMIT, &amp;rknpu_submit)
    S-&gt;&gt;D: dispatch by cmd
    D-&gt;&gt;I: submit_ioctrl(&amp;submit_args)

    Note over I: 解析 subcore_task[0..5]

    loop idx = 0..4 (跳过 task_number == 0)
        I-&gt;&gt;O: submit_one(idx, args)

        Note over O: 按 max_submit_number 分批

        loop 每批 task
            O-&gt;&gt;P: submit_pc(batch_args)

            Note over P: 1. 写 CNA.s_pointer / CORE.s_pointer
            Note over P: 2. 写 PC.base_address = regcmd_base_addr
            Note over P: 3. 写 PC.register_amounts
            Note over P: 4. 写 PC.interrupt_mask / interrupt_clear
            Note over P: 5. 写 PC.task_control (task_number + flags)
            Note over P: 6. 写 PC.task_dma_base_addr
            Note over P: 7. 写 GLOBAL.enable_mask
            Note over P: 8. 写 PC.operation_enable = 1
            Note over P: 9. 写 PC.operation_enable = 0

            P-&gt;&gt;H: 硬件开始执行命令流

            loop 轮询等待
                O-&gt;&gt;H: 读 PC.interrupt_status
                Note over O: status = rknpu_fuzz_status(raw_status)
                alt status &amp; int_mask != 0
                    H--&gt;&gt;O: 完成
                else 未完成 &amp; 未超时
                    Note over O: 继续轮询
                else 超时
                    Note over O: 返回错误
                end
            end

            O-&gt;&gt;H: 写 PC.interrupt_clear = INT_CLEAR_ALL
            Note over O: 写回最后一个 task 的 int_status
        end
    end

    I--&gt;&gt;D: 返回结果
    D--&gt;&gt;S: Ok / Err
    S--&gt;&gt;U: ioctl 返回值
</code></pre>
<h4 id="423-状态机"><a class="header" href="#423-状态机">4.2.3 状态机</a></h4>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; IDLE: 驱动初始化完成

    IDLE --&gt; PARSING: 收到 SUBMIT ioctl
    PARSING --&gt; DISPATCHING: 解析 subcore_task[0..5]

    DISPATCHING --&gt; SUBMITTING: submit_one(idx)
    Note right of DISPATCHING: 跳过 task_number == 0 的子核心

    SUBMITTING --&gt; HW_RUNNING: submit_pc() 写寄存器 + OP_EN=1
    HW_RUNNING --&gt; POLLING: 轮询 interrupt_status

    POLLING --&gt; COMPLETED: status &amp; int_mask != 0
    POLLING --&gt; POLLING: 未完成 &amp; 未超时
    POLLING --&gt; TIMEOUT: 超过 timeout

    COMPLETED --&gt; CLEARING: 写 interrupt_clear
    CLEARING --&gt; NEXT_BATCH: 还有剩余批次?

    NEXT_BATCH --&gt; SUBMITTING: 是，提交下一批
    NEXT_BATCH --&gt; NEXT_CORE: 否，当前子核心完成

    NEXT_CORE --&gt; DISPATCHING: 还有子核心?
    NEXT_CORE --&gt; DONE: 全部完成

    DONE --&gt; IDLE: 返回成功

    TIMEOUT --&gt; ERROR: 返回超时错误
    ERROR --&gt; IDLE: 错误恢复
</code></pre>
<h4 id="424-解析-subcore_task5"><a class="header" href="#424-解析-subcore_task5">4.2.4 解析 <code>subcore_task[5]</code></a></h4>
<p><code>rknpu_submit</code> 包含 <code>subcore_task[5]</code>，每个元素描述一个子核心要执行的 task 切片：</p>
<pre><code>subcore_task[0]: { task_start: 0,  task_number: 10 }  → core 0 执行 task 0~9
subcore_task[1]: { task_start: 10, task_number: 5  }  → core 1 执行 task 10~14
subcore_task[2]: { task_start: 15, task_number: 0  }  → 跳过
subcore_task[3~4]: 跳过
</code></pre>
<p>驱动遍历 <code>idx = 0..5</code>，对 <code>task_number &gt; 0</code> 的子核心调用 <code>submit_one(idx, args)</code>。</p>
<h4 id="425-分批提交max_submit_number"><a class="header" href="#425-分批提交max_submit_number">4.2.5 分批提交（<code>max_submit_number</code>）</a></h4>
<p>每个子核心的 task 可能很多，但硬件一次能处理的 task 数量有上限（<code>max_submit_number</code>，取决于硬件版本）。因此 <code>submit_one()</code> 将 task 分批：</p>
<pre><code>总 task_number = 100, max_submit_number = 12

批次 1: task[0..12]   → submit_pc()
批次 2: task[12..24]  → submit_pc()
...
批次 9: task[96..100]  → submit_pc()
</code></pre>
<h4 id="426-submit_pc-寄存器写入序列"><a class="header" href="#426-submit_pc-寄存器写入序列">4.2.6 <code>submit_pc()</code> 寄存器写入序列</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">步骤</th><th style="text-align: left">寄存器</th><th style="text-align: left">写入值</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><code>CNA.s_pointer</code> / <code>CORE.s_pointer</code></td><td style="text-align: left"><code>0xe + 0x10000000 * core_idx</code></td><td style="text-align: left">初始化子模块指针</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><code>PC.base_address</code></td><td style="text-align: left"><code>regcmd_base_addr</code></td><td style="text-align: left">命令流 DMA 基址</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><code>PC.register_amounts</code></td><td style="text-align: left">计算值</td><td style="text-align: left">命令/寄存器项数量</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><code>PC.interrupt_mask</code></td><td style="text-align: left"><code>task.int_mask</code></td><td style="text-align: left">设置期望的完成中断</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><code>PC.interrupt_clear</code></td><td style="text-align: left"><code>task.int_clear</code></td><td style="text-align: left">清除残留中断</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><code>PC.task_control</code></td><td style="text-align: left"><code>((0x6 | pp_en) &lt;&lt; bits) | task_num</code></td><td style="text-align: left">任务数量 + 控制位</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left"><code>PC.task_dma_base_addr</code></td><td style="text-align: left">task buffer DMA 地址</td><td style="text-align: left">task 描述符数组基址</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left"><code>GLOBAL.enable_mask</code></td><td style="text-align: left"><code>task.enable_mask</code></td><td style="text-align: left">使能相关功能模块</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left"><code>PC.operation_enable</code></td><td style="text-align: left"><code>1</code></td><td style="text-align: left"><strong>触发执行</strong></td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"><code>PC.operation_enable</code></td><td style="text-align: left"><code>0</code></td><td style="text-align: left">清边沿（脉冲触发）</td></tr>
</tbody></table>
</div>
<blockquote>
<p>步骤 9→10 构成一个<strong>上升沿脉冲</strong>，硬件在检测到 OP_EN 从 0→1 时启动命令流执行。</p>
</blockquote>
<h4 id="427-等待完成与中断处理"><a class="header" href="#427-等待完成与中断处理">4.2.7 等待完成与中断处理</a></h4>
<p><strong>Linux 内核驱动</strong>（中断驱动）：</p>
<pre><code>rknpu_irq_handler()
├── 读 INT_STATUS 寄存器
├── rknpu_fuzz_status() → 归一化中断状态
├── 写 INT_CLEAR → 清除中断
└── 唤醒 wait_queue / 信号 dma_fence

rknpu_job_done()
├── 写回 task[i].int_status
└── 信号 DMA fence / 唤醒用户态
</code></pre>
<p><strong>StarryOS Rust 驱动</strong>（轮询模式）：</p>
<pre><code>loop {
    raw_status = read(PC.interrupt_status)
    status = rknpu_fuzz_status(raw_status)

    if status &amp; int_mask != 0 {
        break  // 完成
    }
    if elapsed &gt; timeout {
        return Error::Timeout
    }
    // 继续轮询（yield / sleep）
}
write(PC.interrupt_clear, INT_CLEAR_ALL)  // 0x1ffff
// 写回最后一个 task 的 int_status
</code></pre>
<p><strong><code>rknpu_fuzz_status()</code></strong>：将每个模块的 2-bit 中断组归一化（任一非零 → 全置 1），确保与 <code>int_mask</code> 的比较不会因为硬件只置了部分 bit 而误判为未完成。</p>
<h4 id="428-失败路径"><a class="header" href="#428-失败路径">4.2.8 失败路径</a></h4>
<p><strong>超时</strong>：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">触发条件</th><th style="text-align: left">行为</th><th style="text-align: left">恢复</th></tr></thead><tbody>
<tr><td style="text-align: left">轮询 <code>interrupt_status</code> 超过 <code>submit.timeout</code> 毫秒</td><td style="text-align: left">返回超时错误</td><td style="text-align: left">写 <code>interrupt_clear = 0x1ffff</code>，可能需要 NPU 软复位（<code>ACTION::ACT_RESET</code>）</td></tr>
</tbody></table>
</div>
<p><strong>异常中断</strong>：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">触发条件</th><th style="text-align: left">说明</th><th style="text-align: left">检测</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>DMA_RD_ERR</code> (bit12) 或 <code>DMA_WR_ERR</code> (bit13)</td><td style="text-align: left">DMA 读写错误（地址非法/IOMMU 映射缺失）</td><td style="text-align: left"><code>interrupt_status &amp; 0x3000</code></td></tr>
</tbody></table>
</div>
<p><strong>非法参数</strong>：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">非法条件</th><th style="text-align: left">行为</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>task_number</code></td><td style="text-align: left"><code>== 0</code>（某个 subcore_task）</td><td style="text-align: left">跳过该子核心（非错误）</td></tr>
<tr><td style="text-align: left"><code>core_mask</code></td><td style="text-align: left">无效核心选择</td><td style="text-align: left">返回 <code>EINVAL</code></td></tr>
<tr><td style="text-align: left"><code>task_obj_addr</code></td><td style="text-align: left">无效内核对象地址</td><td style="text-align: left">返回 <code>EFAULT</code></td></tr>
<tr><td style="text-align: left"><code>timeout</code></td><td style="text-align: left"><code>== 0</code></td><td style="text-align: left">使用默认超时值</td></tr>
</tbody></table>
</div>
<h4 id="429-linux-内核驱动-vs-starryos-驱动差异"><a class="header" href="#429-linux-内核驱动-vs-starryos-驱动差异">4.2.9 Linux 内核驱动 vs StarryOS 驱动差异</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">方面</th><th style="text-align: left">Linux rknpu 驱动</th><th style="text-align: left">StarryOS Rust 驱动</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>等待机制</strong></td><td style="text-align: left">中断驱动 + <code>wait_queue</code> + <code>dma_fence</code></td><td style="text-align: left">轮询 <code>interrupt_status</code></td></tr>
<tr><td style="text-align: left"><strong>多任务调度</strong></td><td style="text-align: left">内核 job 队列 + 优先级调度</td><td style="text-align: left">串行提交</td></tr>
<tr><td style="text-align: left"><strong>fence 支持</strong></td><td style="text-align: left">完整 <code>dma_fence</code> + <code>sync_file</code></td><td style="text-align: left">未实现</td></tr>
<tr><td style="text-align: left"><strong>IOMMU</strong></td><td style="text-align: left">RKIOMMU domain attach/detach</td><td style="text-align: left">未实现（物理连续内存）</td></tr>
<tr><td style="text-align: left"><strong>电源管理</strong></td><td style="text-align: left"><code>pm_runtime</code> + <code>devfreq</code></td><td style="text-align: left">直接寄存器操作（最小集）</td></tr>
</tbody></table>
</div>
<h3 id="43-获取输出rknn_outputs_get"><a class="header" href="#43-获取输出rknn_outputs_get">4.3 获取输出（<code>rknn_outputs_get</code>）</a></h3>
<pre><code class="language-c">rknn_output outputs[3];
memset(outputs, 0, sizeof(outputs));
for (int i = 0; i &lt; 3; i++) {
    outputs[i].index = i;
    outputs[i].want_float = 0;
}
rknn_outputs_get(ctx, 3, outputs, NULL);
</code></pre>
<p><strong>闭源库内部流程</strong>：</p>
<pre><code>rknn_outputs_get()
│
├── ioctl(MEM_SYNC, SYNC_FROM_DEVICE)  // invalidate cache
│
├── 遍历 outputs[i]:
│   ├── 从输出 DMA 缓冲读取原始数据
│   ├── 如果 want_float:
│   │   ├── 反量化: INT8 → FP32（val = (qval - zp) * scale）
│   │   └── 格式转换: NC1HWC2 → NCHW/NHWC
│   ├── 如果 is_prealloc:
│   │   └── memcpy → 用户提供的 buf
│   └── 否则:
│       ├── malloc(size) → 分配 buf
│       └── memcpy → buf
│
└── 返回
</code></pre>
<h3 id="44-释放输出"><a class="header" href="#44-释放输出">4.4 释放输出</a></h3>
<pre><code class="language-c">rknn_outputs_release(ctx, 3, outputs);
</code></pre>
<p>释放 <code>rknn_outputs_get</code> 中 <code>is_prealloc == FALSE</code> 时分配的 <code>buf</code>。</p>
<hr />
<h2 id="五阶段-4销毁rknn_destroy"><a class="header" href="#五阶段-4销毁rknn_destroy">五、阶段 4：销毁（<code>rknn_destroy</code>）</a></h2>
<pre><code class="language-c">rknn_destroy(ctx);
</code></pre>
<p><strong>内部流程</strong>：</p>
<pre><code>rknn_destroy()
├── 释放命令流缓冲
│   └── munmap() + ioctl(MEM_DESTROY)
├── 释放 Task 数组
│   └── munmap() + ioctl(MEM_DESTROY)
├── 释放权重内存
│   └── munmap() + ioctl(MEM_DESTROY)
├── 释放内部中间缓冲
│   └── munmap() + ioctl(MEM_DESTROY)
├── 释放输入/输出缓冲
│   └── munmap() + ioctl(MEM_DESTROY)
├── close(drm_fd)
└── free(context)
</code></pre>
<hr />
<h2 id="六零拷贝推理路径"><a class="header" href="#六零拷贝推理路径">六、零拷贝推理路径</a></h2>
<p>使用 <code>RKNN_FLAG_MEM_ALLOC_OUTSIDE</code> 时的高级路径：</p>
<pre><code class="language-c">// 1. 初始化（仅解析模型，不分配 IO 内存）
rknn_init(&amp;ctx, model, size, RKNN_FLAG_MEM_ALLOC_OUTSIDE, NULL);

// 2. 查询内存需求
rknn_mem_size mem_size;
rknn_query(ctx, RKNN_QUERY_MEM_SIZE, &amp;mem_size, sizeof(mem_size));

// 3. 用户分配内存
rknn_tensor_mem* weight_mem = rknn_create_mem(ctx, mem_size.total_weight_size);
rknn_tensor_mem* internal_mem = rknn_create_mem(ctx, mem_size.total_internal_size);

// 4. 绑定内存
rknn_set_weight_mem(ctx, weight_mem);
rknn_set_internal_mem(ctx, internal_mem);

// 5. 查询原生输入/输出属性
rknn_tensor_attr input_attr, output_attr;
input_attr.index = 0;
rknn_query(ctx, RKNN_QUERY_NATIVE_INPUT_ATTR, &amp;input_attr, sizeof(input_attr));

// 6. 分配并绑定 IO 内存
rknn_tensor_mem* input_mem = rknn_create_mem(ctx, input_attr.size_with_stride);
rknn_set_io_mem(ctx, input_mem, &amp;input_attr);

// 7. 直接写入 native layout 数据（无格式转换开销）
memcpy(input_mem-&gt;virt_addr, native_data, size);

// 8. 推理
rknn_run(ctx, NULL);

// 9. 直接读取输出（无拷贝）
float* output = (float*)output_mem-&gt;virt_addr;
</code></pre>
<p>此路径避免了 <code>rknn_inputs_set</code> 和 <code>rknn_outputs_get</code> 中的格式转换和数据拷贝。</p>
<hr />
<h2 id="七异步推理路径"><a class="header" href="#七异步推理路径">七、异步推理路径</a></h2>
<pre><code class="language-c">// 初始化时启用异步
rknn_init(&amp;ctx, model, size, RKNN_FLAG_ASYNC_MASK, NULL);

// 帧 0
rknn_inputs_set(ctx, 1, inputs_frame0);
rknn_run(ctx, NULL);
// rknn_outputs_get 返回的是上一帧结果（第一次调用返回空）
rknn_outputs_get(ctx, n, outputs, NULL);

// 帧 1
rknn_inputs_set(ctx, 1, inputs_frame1);
rknn_run(ctx, NULL);
// 返回帧 0 的结果
rknn_outputs_get(ctx, n, outputs, NULL);
</code></pre>
<p>异步模式下 <code>rknn_outputs_get</code> 不等待当前帧完成，直接返回上一帧结果，提高单线程帧率。</p>
<hr />
<h2 id="八dma-fence-路径"><a class="header" href="#八dma-fence-路径">八、DMA Fence 路径</a></h2>
<pre><code class="language-c">// 初始化时启用 fence
rknn_init(&amp;ctx, model, size,
    RKNN_FLAG_FENCE_IN_OUTSIDE | RKNN_FLAG_FENCE_OUT_OUTSIDE, NULL);

// 推理时传入/获取 fence fd
rknn_run_extend extend;
extend.fence_fd = input_fence_fd;  // 等待输入数据就绪
extend.non_block = 1;
rknn_run(ctx, &amp;extend);

// extend.fence_fd 现在是输出 fence fd
// 可以传给 GPU/RGA 等下游设备
</code></pre>
<p>对应内核驱动的 <code>RKNPU_JOB_FENCE_IN</code> / <code>RKNPU_JOB_FENCE_OUT</code> 标志。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存管理与零拷贝"><a class="header" href="#内存管理与零拷贝">内存管理与零拷贝</a></h1>
<p>闭源库的内存管理策略，包括 DMA 内存分配、cache 同步、零拷贝机制。</p>
<blockquote>
<p>逆向来源：<code>rknn_api.h</code>、<code>rknpu_ioctl.h</code>、<code>npu_interface.c</code>、<code>llama0.c</code>。</p>
</blockquote>
<hr />
<h2 id="一内存分配路径"><a class="header" href="#一内存分配路径">一、内存分配路径</a></h2>
<h3 id="11-闭源库内部分配"><a class="header" href="#11-闭源库内部分配">1.1 闭源库内部分配</a></h3>
<p>闭源库通过 DRM ioctl 分配 DMA 内存：</p>
<pre><code>rknn_create_mem(ctx, size)
    ↓
ioctl(DRM_IOCTL_RKNPU_MEM_CREATE, {
    .size = size,
    .flags = flags
})
    ↓ 返回
{ handle, obj_addr, dma_addr }
    ↓
ioctl(DRM_IOCTL_RKNPU_MEM_MAP, { handle })
    ↓ 返回
{ offset }
    ↓
mmap(fd, size, offset)
    ↓ 返回
virt_addr
    ↓
填充 rknn_tensor_mem {
    .virt_addr = virt_addr,
    .phys_addr = dma_addr,    // 实际是 IOVA
    .fd = drm_fd,
    .size = size,
    .priv_data = 内部状态指针
}
</code></pre>
<h3 id="12-内存类型标志"><a class="header" href="#12-内存类型标志">1.2 内存类型标志</a></h3>
<pre><code class="language-c">enum e_rknpu_mem_type {
    RKNPU_MEM_CONTIGUOUS      = 0 &lt;&lt; 0,  // 物理连续（默认）
    RKNPU_MEM_NON_CONTIGUOUS  = 1 &lt;&lt; 0,  // 物理不连续
    RKNPU_MEM_NON_CACHEABLE   = 0 &lt;&lt; 1,  // 不可缓存（默认）
    RKNPU_MEM_CACHEABLE       = 1 &lt;&lt; 1,  // 可缓存
    RKNPU_MEM_WRITE_COMBINE   = 1 &lt;&lt; 2,  // 写合并
    RKNPU_MEM_KERNEL_MAPPING  = 1 &lt;&lt; 3,  // 内核态映射
    RKNPU_MEM_IOMMU           = 1 &lt;&lt; 4,  // IOMMU 映射
    RKNPU_MEM_ZEROING         = 1 &lt;&lt; 5,  // 零初始化
    RKNPU_MEM_SECURE          = 1 &lt;&lt; 6,  // 安全缓冲
    RKNPU_MEM_NON_DMA32       = 1 &lt;&lt; 7,  // 非 DMA32 区域
    RKNPU_MEM_TRY_ALLOC_SRAM  = 1 &lt;&lt; 8,  // 尝试 SRAM 分配
};
</code></pre>
<h3 id="13-闭源库的内存分配策略"><a class="header" href="#13-闭源库的内存分配策略">1.3 闭源库的内存分配策略</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">用途</th><th style="text-align: left">flags</th><th style="text-align: left">原因</th></tr></thead><tbody>
<tr><td style="text-align: left">Task 数组</td><td style="text-align: left"><code>KERNEL_MAPPING</code></td><td style="text-align: left">内核驱动需要直接读取 task 字段</td></tr>
<tr><td style="text-align: left">命令流（regcmd）</td><td style="text-align: left">0</td><td style="text-align: left">硬件通过 DMA 读取，不需要内核映射</td></tr>
<tr><td style="text-align: left">权重</td><td style="text-align: left"><code>KERNEL_MAPPING</code> 或 0</td><td style="text-align: left">取决于是否需要内核态访问</td></tr>
<tr><td style="text-align: left">输入/输出</td><td style="text-align: left">0 或 <code>CACHEABLE</code></td><td style="text-align: left">用户频繁读写时用 CACHEABLE</td></tr>
<tr><td style="text-align: left">内部中间缓冲</td><td style="text-align: left">0</td><td style="text-align: left">仅硬件读写</td></tr>
</tbody></table>
</div>
<p><strong>逆向证据</strong>：<code>bench_mark.c</code> 中 tasks 用 <code>RKNPU_MEM_KERNEL_MAPPING</code>，其余用 0。</p>
<hr />
<h2 id="二cache-同步"><a class="header" href="#二cache-同步">二、Cache 同步</a></h2>
<h3 id="21-同步模式"><a class="header" href="#21-同步模式">2.1 同步模式</a></h3>
<pre><code class="language-c">enum e_rknpu_mem_sync_mode {
    RKNPU_MEM_SYNC_TO_DEVICE   = 1 &lt;&lt; 0,  // CPU → 设备（flush）
    RKNPU_MEM_SYNC_FROM_DEVICE = 1 &lt;&lt; 1,  // 设备 → CPU（invalidate）
};
</code></pre>
<h3 id="22-同步时机"><a class="header" href="#22-同步时机">2.2 同步时机</a></h3>
<pre><code>CPU 写入输入数据
    ↓
ioctl(MEM_SYNC, { flags=SYNC_TO_DEVICE, obj_addr, offset, size })
    ↓ flush CPU cache
NPU 可以安全读取
    ↓
NPU 执行完毕，写入输出
    ↓
ioctl(MEM_SYNC, { flags=SYNC_FROM_DEVICE, obj_addr, offset, size })
    ↓ invalidate CPU cache
CPU 可以安全读取输出
</code></pre>
<h3 id="23-闭源库的-cache-优化标志"><a class="header" href="#23-闭源库的-cache-优化标志">2.3 闭源库的 cache 优化标志</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">标志</th><th style="text-align: left">效果</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>RKNN_FLAG_DISABLE_FLUSH_INPUT_MEM_CACHE</code></td><td style="text-align: left">跳过输入 flush（用户自行保证）</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_DISABLE_FLUSH_OUTPUT_MEM_CACHE</code></td><td style="text-align: left">跳过输出 invalidate（输出由 GPU/RGA 消费）</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="三零拷贝机制"><a class="header" href="#三零拷贝机制">三、零拷贝机制</a></h2>
<h3 id="31-标准路径-vs-零拷贝路径"><a class="header" href="#31-标准路径-vs-零拷贝路径">3.1 标准路径 vs 零拷贝路径</a></h3>
<p><strong>标准路径</strong>（<code>rknn_inputs_set</code> + <code>rknn_outputs_get</code>）：</p>
<pre><code>用户缓冲 → [格式转换] → [类型转换] → memcpy → DMA 缓冲 → NPU
NPU → DMA 缓冲 → memcpy → [反量化] → [格式转换] → 用户缓冲
</code></pre>
<p>至少 2 次 memcpy + 可能的格式/类型转换。</p>
<p><strong>零拷贝路径</strong>（<code>rknn_set_io_mem</code>）：</p>
<pre><code>用户直接写入 DMA 缓冲（native layout）→ NPU
NPU → DMA 缓冲 → 用户直接读取
</code></pre>
<p>0 次 memcpy，但用户需要自行处理 native layout。</p>
<h3 id="32-零拷贝-api"><a class="header" href="#32-零拷贝-api">3.2 零拷贝 API</a></h3>
<h4 id="内部分配"><a class="header" href="#内部分配">内部分配</a></h4>
<pre><code class="language-c">rknn_tensor_mem* rknn_create_mem(rknn_context ctx, uint32_t size);
</code></pre>
<p>闭源库内部调用 <code>ioctl(MEM_CREATE)</code> + <code>ioctl(MEM_MAP)</code> + <code>mmap()</code>。</p>
<h4 id="带标志分配"><a class="header" href="#带标志分配">带标志分配</a></h4>
<pre><code class="language-c">rknn_tensor_mem* rknn_create_mem2(rknn_context ctx, uint64_t size, uint64_t alloc_flags);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">alloc_flags</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>RKNN_FLAG_MEMORY_CACHEABLE</code></td><td style="text-align: left">可缓存内存</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_MEMORY_NON_CACHEABLE</code></td><td style="text-align: left">不可缓存内存</td></tr>
<tr><td style="text-align: left"><code>RKNN_FLAG_MEMORY_TRY_ALLOC_SRAM</code></td><td style="text-align: left">尝试 SRAM</td></tr>
</tbody></table>
</div>
<h4 id="从外部-fd-创建"><a class="header" href="#从外部-fd-创建">从外部 fd 创建</a></h4>
<pre><code class="language-c">rknn_tensor_mem* rknn_create_mem_from_fd(rknn_context ctx,
    int32_t fd, void* virt_addr, uint32_t size, int32_t offset);
</code></pre>
<p>用于导入其他设备（如 camera、GPU）分配的 DMA buffer。</p>
<h4 id="从物理地址创建"><a class="header" href="#从物理地址创建">从物理地址创建</a></h4>
<pre><code class="language-c">rknn_tensor_mem* rknn_create_mem_from_phys(rknn_context ctx,
    uint64_t phys_addr, void* virt_addr, uint32_t size);
</code></pre>
<h4 id="从-mb_blk-创建"><a class="header" href="#从-mb_blk-创建">从 mb_blk 创建</a></h4>
<pre><code class="language-c">rknn_tensor_mem* rknn_create_mem_from_mb_blk(rknn_context ctx,
    void* mb_blk, int32_t offset);
</code></pre>
<p>用于 Rockchip 多媒体框架的内存块。</p>
<h4 id="销毁"><a class="header" href="#销毁">销毁</a></h4>
<pre><code class="language-c">int rknn_destroy_mem(rknn_context ctx, rknn_tensor_mem* mem);
</code></pre>
<p><strong>逆向推断</strong>：内部根据 <code>mem-&gt;flags</code> 判断是否需要 <code>munmap()</code> 和 <code>ioctl(MEM_DESTROY)</code>：</p>
<ul>
<li><code>RKNN_TENSOR_MEMORY_FLAGS_ALLOC_INSIDE</code> → 完整释放</li>
<li><code>RKNN_TENSOR_MEMORY_FLAGS_FROM_FD</code> → 仅释放包装结构</li>
<li><code>RKNN_TENSOR_MEMORY_FLAGS_FROM_PHYS</code> → 仅释放包装结构</li>
</ul>
<h4 id="cache-同步"><a class="header" href="#cache-同步">Cache 同步</a></h4>
<pre><code class="language-c">int rknn_mem_sync(rknn_context context, rknn_tensor_mem* mem, rknn_mem_sync_mode mode);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">mode</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>RKNN_MEMORY_SYNC_TO_DEVICE</code></td><td style="text-align: left">CPU 写完后调用</td></tr>
<tr><td style="text-align: left"><code>RKNN_MEMORY_SYNC_FROM_DEVICE</code></td><td style="text-align: left">读取设备输出前调用</td></tr>
<tr><td style="text-align: left"><code>RKNN_MEMORY_SYNC_BIDIRECTIONAL</code></td><td style="text-align: left">双向同步</td></tr>
</tbody></table>
</div>
<p><strong>逆向推断</strong>：内部调用 <code>ioctl(DRM_IOCTL_RKNPU_MEM_SYNC, { flags, obj_addr, offset, size })</code>。</p>
<h3 id="33-io-内存绑定"><a class="header" href="#33-io-内存绑定">3.3 IO 内存绑定</a></h3>
<pre><code class="language-c">int rknn_set_io_mem(rknn_context ctx, rknn_tensor_mem* mem, rknn_tensor_attr* attr);
</code></pre>
<p>将用户分配的内存绑定为模型的输入或输出。<code>attr-&gt;index</code> 指定输入/输出索引。</p>
<pre><code class="language-c">int rknn_set_weight_mem(rknn_context ctx, rknn_tensor_mem* mem);
int rknn_set_internal_mem(rknn_context ctx, rknn_tensor_mem* mem);
</code></pre>
<p>绑定权重和内部内存。需配合 <code>RKNN_FLAG_MEM_ALLOC_OUTSIDE</code> 使用。</p>
<hr />
<h2 id="四sram-管理"><a class="header" href="#四sram-管理">四、SRAM 管理</a></h2>
<p>RK3588 NPU 有片上 SRAM，可用于减少 DDR 带宽：</p>
<pre><code class="language-c">// 查询 SRAM 大小
rknn_mem_size mem_size;
rknn_query(ctx, RKNN_QUERY_MEM_SIZE, &amp;mem_size, sizeof(mem_size));
// mem_size.total_sram_size — 总 SRAM 大小
// mem_size.free_sram_size  — 空闲 SRAM 大小

// 也可通过 ioctl 查询
struct rknpu_action action = { .flags = RKNPU_GET_TOTAL_SRAM_SIZE };
ioctl(fd, DRM_IOCTL_RKNPU_ACTION, &amp;action);
</code></pre>
<p>启用 SRAM 分配：</p>
<ul>
<li>初始化时设置 <code>RKNN_FLAG_ENABLE_SRAM</code></li>
<li>内存分配时使用 <code>RKNPU_MEM_TRY_ALLOC_SRAM</code> 或 <code>RKNN_FLAG_MEMORY_TRY_ALLOC_SRAM</code></li>
</ul>
<hr />
<h2 id="五npu_llama-的-buffer-池化策略"><a class="header" href="#五npu_llama-的-buffer-池化策略">五、npu_llama 的 Buffer 池化策略</a></h2>
<p><code>llama0.c</code> 展示了一种用户态 buffer 池化方案，避免频繁的 DMA 内存分配/释放：</p>
<pre><code class="language-c">#define MAX_BUFFER_POOL_SIZE 8

typedef struct {
    void*    data;
    uint64_t dma;
    uint64_t obj;
    uint32_t handle;
    size_t   size;
    int      in_use;
} NPUBuffer;

// 预分配不同大小的 buffer
size_t sizes[] = { 512KB, 1MB, 2MB, 512KB, 256KB, 256KB, 128KB, 128KB };
for (int i = 0; i &lt; 8; i++) {
    pool[i].data = mem_allocate(fd, sizes[i], &amp;pool[i].dma, ...);
}

// 运行时从池中取用
NPUBuffer* buf = get_buffer_from_pool(t, required_size);
// ... 使用 buf-&gt;data / buf-&gt;dma ...
release_buffer_to_pool(buf);
</code></pre>
<p>闭源库内部很可能也使用类似的池化策略来管理内部中间缓冲。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭源库内部机制"><a class="header" href="#闭源库内部机制">闭源库内部机制</a></h1>
<p>命令流生成、Task 构造、多核切分、数据格式转换等闭源库内部逻辑的逆向分析。</p>
<blockquote>
<p>逆向来源：开源 demo <code>npu_matmul.c</code>、<code>bench_mark.c</code>、<code>llama0.c</code>、内核驱动 <code>rknpu_job.c</code>、StarryOS Rust 驱动。</p>
</blockquote>
<hr />
<h2 id="一命令流生成"><a class="header" href="#一命令流生成">一、命令流生成</a></h2>
<h3 id="11-命令流格式"><a class="header" href="#11-命令流格式">1.1 命令流格式</a></h3>
<p>每条命令是一个 64-bit 值，编码为：</p>
<pre><code> 63        48 47        16 15         0
┌────────────┬─────────────┬───────────┐
│  模块 ID   │  寄存器值    │ 寄存器偏移 │
│  (16-bit)  │  (32-bit)   │ (16-bit)  │
└────────────┴─────────────┴───────────┘
</code></pre>
<pre><code class="language-c">#define NPUOP(op, value, reg) \
    (((uint64_t)(op &amp; 0xffff)) &lt;&lt; 48) | \
    (((uint64_t)(value &amp; 0xffffffff)) &lt;&lt; 16) | \
    (uint64_t)(reg &amp; 0xffff)
</code></pre>
<h3 id="12-模块-id-编码"><a class="header" href="#12-模块-id-编码">1.2 模块 ID 编码</a></h3>
<pre><code class="language-c">#define BLOCK_PC       0x0100
#define BLOCK_CNA      0x0200
#define BLOCK_CORE     0x0800
#define BLOCK_DPU      0x1000
#define BLOCK_DPU_RDMA 0x2000
#define BLOCK_PPU      0x4000
#define BLOCK_PPU_RDMA 0x8000

#define PC_OP_01     0x01    // 寄存器写入标志
#define PC_OP_40     0x40    // 未知用途
#define PC_OP_ENABLE 0x80    // 使能标志

#define OP_REG_CNA  (BLOCK_CNA  | PC_OP_01)  // 0x0201
#define OP_REG_CORE (BLOCK_CORE | PC_OP_01)  // 0x0801
#define OP_REG_DPU  (BLOCK_DPU  | PC_OP_01)  // 0x1001
#define OP_ENABLE   (PC_OP_ENABLE | PC_OP_01) // 0x0081
</code></pre>
<h3 id="13-命令流结构以-matmul-为例"><a class="header" href="#13-命令流结构以-matmul-为例">1.3 命令流结构（以 matmul 为例）</a></h3>
<p>一个典型的 CNA→CORE→DPU 流水线命令流包含约 108 条指令：</p>
<pre><code>ops[0]     DPU_S_POINTER = 0xE          ← DPU 寄存器组指针
ops[1~28]  CNA 寄存器（卷积参数）         ← 28 条
ops[29~40] CNA 权重解压缩寄存器          ← 12 条
ops[41~42] CNA 补充寄存器                ← 2 条
ops[43]    CNA_S_POINTER = 0xE          ← CNA 寄存器组指针
ops[44~49] CORE 寄存器                   ← 6 条
ops[50]    CORE_S_POINTER = 0xE         ← CORE 寄存器组指针
ops[51~106] DPU 寄存器（后处理参数）      ← 56 条
ops[107]   PC_OPERATION_ENABLE           ← 全局使能
</code></pre>
<p>最后一条指令触发硬件开始执行：</p>
<pre><code class="language-c">ops[107] = NPUOP(OP_ENABLE,
    PC_ENABLE_DPU | PC_ENABLE_CNA | PC_ENABLE,  // 0x0d
    PC_OPERATION_ENABLE);                         // 0x0008
</code></pre>
<h3 id="14-s_pointer-寄存器"><a class="header" href="#14-s_pointer-寄存器">1.4 S_POINTER 寄存器</a></h3>
<p>每个模块有一个 <code>S_POINTER</code> 寄存器（偏移 <code>0x_004</code>），用于切换寄存器组（乒乓机制）：</p>
<pre><code class="language-c">ops[0]  = NPUOP(OP_REG_DPU,  0xE, DPU_S_POINTER);   // 0x4004
ops[43] = NPUOP(OP_REG_CNA,  0xE, CNA_S_POINTER);   // 0x1004
ops[50] = NPUOP(OP_REG_CORE, 0xE, CORE_S_POINTER);  // 0x3004
</code></pre>
<p>值 <code>0xE</code> 的含义尚未完全逆向，推测与寄存器组选择和同步有关。</p>
<hr />
<h2 id="二cna-参数填充"><a class="header" href="#二cna-参数填充">二、CNA 参数填充</a></h2>
<p>CNA（Convolution Neural-network Accelerator）负责卷积计算的数据加载和 MAC 阵列控制。</p>
<h3 id="21-cna-描述符"><a class="header" href="#21-cna-描述符">2.1 CNA 描述符</a></h3>
<pre><code class="language-c">typedef struct npu_cna_desc {
    uint8_t  conv_mode;          // 卷积模式（0=direct）
    uint8_t  in_precision;       // 输入精度（0=INT8, 2=FP16）
    uint8_t  proc_precision;     // 处理精度
    uint8_t  kernel_groups;      // 权重分组数
    uint16_t feature_grains;     // 特征粒度
    uint8_t  conv_x_stride;      // X 方向步长
    uint8_t  conv_y_stride;      // Y 方向步长
    uint16_t datain_width;       // 输入宽度
    uint16_t datain_height;      // 输入高度
    uint16_t datain_channel;     // 输入通道数
    uint16_t dataout_width;      // 输出宽度
    uint32_t dataout_atomics;    // 输出原子数
    uint32_t weight_bytes;       // 权重总字节数
    uint32_t weight_bytes_per_kernel; // 每个 kernel 的权重字节数
    uint8_t  weight_width;       // 权重宽度
    uint8_t  weight_height;      // 权重高度
    uint16_t weight_kernels;     // 权重 kernel 数
    uint8_t  weight_bank;        // 权重 CBUF bank 数
    uint8_t  data_bank;          // 数据 CBUF bank 数
    uint16_t data_entries;       // 数据 CBUF 条目数
    uint32_t feature_base_addr;  // 特征数据 DMA 基地址
    uint32_t line_stride;        // 行步长
    int32_t  surf_stride;        // 面步长
    // ... 更多字段
} npu_cna_desc;
</code></pre>
<h3 id="22-cbuf-bank-分配"><a class="header" href="#22-cbuf-bank-分配">2.2 CBUF Bank 分配</a></h3>
<p>CBUF 是 CNA 内部的片上缓冲，共 12 个 bank，每个 32KB：</p>
<pre><code class="language-c">#define NPU_CBUF_BANK_SIZE 32768   // 32KB
#define NPU_CBUF_BANKS     12

// 分配策略（从 gen_matmul_fp16 逆向）：
int weight_banks = ceil(weight_bytes / NPU_CBUF_BANK_SIZE);
int data_banks = NPU_CBUF_BANKS - weight_banks;
// 确保 data_banks &gt;= 1
</code></pre>
<p>闭源库需要为每层计算最优的 bank 分配，平衡权重和数据的缓存需求。</p>
<h3 id="23-matmul--卷积映射"><a class="header" href="#23-matmul--卷积映射">2.3 Matmul → 卷积映射</a></h3>
<p>NPU 没有专用的 matmul 单元，矩阵乘法通过卷积实现：</p>
<pre><code>矩阵乘法 C[M×N] = A[M×K] × B[K×N]
    ↓ 映射为
1×1 卷积：
    输入特征: A 重排为 [M, K, 1, 1]（M 个样本，K 通道）
    权重:     B 重排为 [N, K, 1, 1]（N 个 1×1 kernel，K 通道）
    输出:     C 为 [M, N, 1, 1]
</code></pre>
<p><strong>逆向证据</strong>：<code>gen_matmul_fp16()</code> 中设置 <code>conv_mode = direct_convolution</code>，<code>weight_width = weight_height = 1</code>，<code>conv_x_stride = conv_y_stride = 1</code>。</p>
<hr />
<h2 id="三dpu-参数填充"><a class="header" href="#三dpu-参数填充">三、DPU 参数填充</a></h2>
<p>DPU（Data Processing Unit）负责后处理：BS（Bias/Scale）、BN（Batch Norm）、EW（Element-wise）、LUT（激活函数）、输出转换。</p>
<h3 id="31-dpu-描述符"><a class="header" href="#31-dpu-描述符">3.1 DPU 描述符</a></h3>
<pre><code class="language-c">typedef struct npu_dpu_desc {
    uint8_t  flying_mode;       // 0=on-flying（从 CORE 直接接收）
    uint8_t  output_mode;       // 输出模式
    uint8_t  conv_mode;         // 卷积模式
    uint8_t  out_precision;     // 输出精度
    uint8_t  in_precision;      // 输入精度
    uint8_t  proc_precision;    // 处理精度
    uint32_t dst_base_addr;     // 输出 DMA 基地址
    uint32_t dst_surf_stride;   // 输出面步长
    uint16_t width, height;     // 输出尺寸
    uint16_t channel;           // 输出通道
    // BS 旁路控制
    uint8_t  bs_bypass;         // 1=旁路 BS
    uint8_t  bs_alu_bypass;     // 1=旁路 BS ALU
    uint8_t  bs_mul_bypass;     // 1=旁路 BS MUL
    uint8_t  bs_relu_bypass;    // 1=旁路 BS ReLU
    // BN 旁路控制
    uint8_t  bn_bypass;
    uint8_t  bn_alu_bypass;
    uint8_t  bn_mul_bypass;
    uint8_t  bn_relu_bypass;
    // EW 旁路控制
    uint8_t  ew_bypass;
    uint8_t  ew_op_bypass;
    uint8_t  ew_lut_bypass;
    uint8_t  ew_op_cvt_bypass;
    uint8_t  ew_relu_bypass;
    // 输出转换
    uint8_t  fp32tofp16_en;     // FP32→FP16 使能
    uint16_t out_cvt_scale;     // 输出缩放因子
    uint32_t surf_add;          // 面地址增量
} npu_dpu_desc;
</code></pre>
<h3 id="32-旁路模式"><a class="header" href="#32-旁路模式">3.2 旁路模式</a></h3>
<p>对于简单的 matmul，DPU 大部分功能被旁路：</p>
<pre><code class="language-c">// gen_matmul_task() 中的典型设置：
dpu_desc.bs_bypass = 1;      // 无 bias
dpu_desc.bs_alu_bypass = 1;
dpu_desc.bs_mul_bypass = 1;
dpu_desc.bs_relu_bypass = 1;
dpu_desc.bn_bypass = 1;      // 无 batch norm
dpu_desc.bn_alu_bypass = 1;
dpu_desc.bn_mul_bypass = 1;
dpu_desc.bn_relu_bypass = 1;
dpu_desc.ew_bypass = 1;      // 无 element-wise
dpu_desc.ew_op_bypass = 1;
dpu_desc.ew_lut_bypass = 1;
dpu_desc.ew_op_cvt_bypass = 1;
dpu_desc.ew_relu_bypass = 1;
</code></pre>
<p>闭源库在编译复杂模型时，会根据每层的算子类型选择性启用这些功能。</p>
<hr />
<h2 id="四task-构造"><a class="header" href="#四task-构造">四、Task 构造</a></h2>
<h3 id="41-task-结构"><a class="header" href="#41-task-结构">4.1 Task 结构</a></h3>
<pre><code class="language-c">struct rknpu_task {
    uint32_t flags;           // 任务标志
    uint32_t op_idx;          // 算子索引
    uint32_t enable_mask;     // 模块使能掩码
    uint32_t int_mask;        // 期望的中断掩码
    uint32_t int_clear;       // 中断清除值
    uint32_t int_status;      // [内核写回] 实际中断状态
    uint32_t regcfg_amount;   // 命令流中的指令数量
    uint32_t regcfg_offset;   // 命令流偏移（字节）
    uint64_t regcmd_addr;     // 命令流 DMA 地址
};
</code></pre>
<h3 id="42-关键字段计算"><a class="header" href="#42-关键字段计算">4.2 关键字段计算</a></h3>
<p><strong><code>enable_mask</code></strong>（偏移 <code>0xF008</code>）：</p>
<pre><code class="language-c">#define PC_ENABLE      0x01   // 全局使能
#define PC_ENABLE_CNA  0x04   // CNA 中断使能
#define PC_ENABLE_DPU  0x08   // DPU 中断使能
#define PC_ENABLE_PPU  0x10   // PPU 中断使能

// CNA + CORE + DPU 流水线：
enable_mask = PC_ENABLE | PC_ENABLE_CNA | PC_ENABLE_DPU;  // 0x0d
</code></pre>
<p><strong><code>int_mask</code></strong>（偏移 <code>0x0020</code>）：</p>
<pre><code class="language-c">// 中断位定义（从内核驱动 rknpu_ioctl.h 推断）：
// bit[8]  = DPU group 0 完成
// bit[9]  = DPU group 1 完成
// 对于单 task matmul：
int_mask = 0x300;  // 等待 DPU group 0 和 group 1 完成
</code></pre>
<p><strong><code>int_clear</code></strong>：</p>
<pre><code class="language-c">int_clear = 0x1ffff;  // 清除所有 17 位中断
</code></pre>
<p><strong><code>regcfg_amount</code></strong>：</p>
<pre><code class="language-c">// 命令流指令数 - 额外保留量 - 尾部保留
regcfg_amount = total_ops - RKNPU_PC_DATA_EXTRA_AMOUNT - 4;
// RKNPU_PC_DATA_EXTRA_AMOUNT = 4（内核驱动会额外加回）
</code></pre>
<p><strong>逆向证据</strong>：内核驱动 <code>rknpu_job_subcore_commit_pc()</code> 中：</p>
<pre><code class="language-c">amount = task-&gt;regcfg_amount + rknpu-&gt;config-&gt;pc_data_extra_amount;
</code></pre>
<h3 id="43-多-task-场景"><a class="header" href="#43-多-task-场景">4.3 多 Task 场景</a></h3>
<p>对于多层网络，闭源库生成多个 task，每个 task 对应一层或一组层：</p>
<pre><code>Task[0]: 第 1 层卷积（CNA+CORE+DPU）
    regcmd_addr → 命令流偏移 0
    regcfg_amount = 108
Task[1]: 第 2 层卷积
    regcmd_addr → 命令流偏移 108*8
    regcfg_amount = 108
...
Task[N-1]: 最后一层
</code></pre>
<hr />
<h2 id="五多核切分"><a class="header" href="#五多核切分">五、多核切分</a></h2>
<h3 id="51-submit-结构"><a class="header" href="#51-submit-结构">5.1 Submit 结构</a></h3>
<pre><code class="language-c">struct rknpu_submit {
    uint32_t flags;
    uint32_t timeout;
    uint32_t task_start;
    uint32_t task_number;        // 总 task 数
    uint32_t core_mask;          // 使用的核心掩码
    struct rknpu_subcore_task subcore_task[5]; // 每核心的 task 范围
};

struct rknpu_subcore_task {
    uint32_t task_start;         // 起始 task 索引
    uint32_t task_number;        // task 数量
};
</code></pre>
<h3 id="52-单核模式"><a class="header" href="#52-单核模式">5.2 单核模式</a></h3>
<pre><code class="language-c">submit.core_mask = 0x1;  // 仅核心 0
submit.subcore_task[0] = { .task_start = 0, .task_number = N };
submit.subcore_task[1] = { .task_start = N, .task_number = 0 };  // 哨兵
submit.subcore_task[2] = { .task_start = N, .task_number = 0 };
</code></pre>
<p><strong>逆向证据</strong>：<code>bench_mark.c</code> 和 <code>llama0.c</code> 均使用此模式。</p>
<h3 id="53-多核模式闭源库独有"><a class="header" href="#53-多核模式闭源库独有">5.3 多核模式（闭源库独有）</a></h3>
<p>闭源库将 task 数组切分到多个核心：</p>
<pre><code>假设 12 个 task，3 核心模式：
submit.core_mask = 0x7;  // 核心 0+1+2
submit.subcore_task[0] = { 0, 4 };   // 核心 0: task 0~3
submit.subcore_task[1] = { 4, 4 };   // 核心 1: task 4~7
submit.subcore_task[2] = { 8, 4 };   // 核心 2: task 8~11
</code></pre>
<p>切分策略是闭源库的核心竞争力之一，涉及：</p>
<ul>
<li>层间数据依赖分析</li>
<li>计算量均衡</li>
<li>内存带宽分配</li>
<li>CBUF 冲突避免</li>
</ul>
<h3 id="54-乒乓模式"><a class="header" href="#54-乒乓模式">5.4 乒乓模式</a></h3>
<p><code>RKNPU_JOB_PINGPONG</code> 标志启用硬件乒乓机制：</p>
<pre><code>Task[0] 在 group 0 执行
    ↓ 完成，触发 group 0 中断
Task[1] 在 group 1 执行（与 Task[0] 的 DPU 输出重叠）
    ↓ 完成，触发 group 1 中断
Task[2] 在 group 0 执行
    ...
</code></pre>
<p>这允许流水线执行：当 Task[N] 在 DPU 阶段输出时，Task[N+1] 已经在 CNA 阶段加载数据。</p>
<hr />
<h2 id="六数据格式转换"><a class="header" href="#六数据格式转换">六、数据格式转换</a></h2>
<h3 id="61-特征数据排列feature_data"><a class="header" href="#61-特征数据排列feature_data">6.1 特征数据排列（<code>feature_data</code>）</a></h3>
<p>从 <code>npu_matmul.h</code> 导出的函数，将行主序坐标转换为 NPU native layout 索引：</p>
<pre><code class="language-c">int feature_data(int C, int H, int W, int C2, int c, int h, int w);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">C</td><td style="text-align: left">通道总数</td></tr>
<tr><td style="text-align: left">H</td><td style="text-align: left">高度</td></tr>
<tr><td style="text-align: left">W</td><td style="text-align: left">宽度</td></tr>
<tr><td style="text-align: left">C2</td><td style="text-align: left">通道分组大小（FP16=8, INT8=16, FP32=4）</td></tr>
<tr><td style="text-align: left">c, h, w</td><td style="text-align: left">1-indexed 坐标</td></tr>
</tbody></table>
</div>
<p><strong>逆向推断的公式</strong>：</p>
<pre><code>native_index = (c-1)/C2 * (H*W*C2) + (h-1)*W*C2 + (w-1)*C2 + (c-1)%C2
</code></pre>
<p>这对应 <code>NC1HWC2</code> 格式：<code>(N, ceil(C/C2), H, W, C2)</code>。</p>
<h3 id="62-权重排列"><a class="header" href="#62-权重排列">6.2 权重排列</a></h3>
<h4 id="fp16-权重weight_fp16"><a class="header" href="#fp16-权重weight_fp16">FP16 权重（<code>weight_fp16</code>）</a></h4>
<pre><code class="language-c">int weight_fp16(int C, int k, int c);
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">C</td><td style="text-align: left">输入通道数（K 维度）</td></tr>
<tr><td style="text-align: left">k</td><td style="text-align: left">kernel 索引（1-indexed）</td></tr>
<tr><td style="text-align: left">c</td><td style="text-align: left">通道索引（1-indexed）</td></tr>
</tbody></table>
</div>
<p>对应 native layout <code>(N/16, K/32, 16, 32)</code> 的 FP16 变体。</p>
<h4 id="int8-权重weight_int8"><a class="header" href="#int8-权重weight_int8">INT8 权重（<code>weight_int8</code>）</a></h4>
<pre><code class="language-c">int weight_int8(int C, int k, int c);
</code></pre>
<p>对应 native layout <code>(N/32, K/32, 32, 32)</code>。</p>
<h3 id="63-闭源库的格式转换链"><a class="header" href="#63-闭源库的格式转换链">6.3 闭源库的格式转换链</a></h3>
<pre><code>用户输入（NHWC, UINT8）
    ↓ rknn_inputs_set()
    ├── NHWC → NCHW（如果模型需要）
    ├── UINT8 → INT8（减去 zp）
    └── NCHW → NC1HWC2（NPU native）
    ↓
NPU 执行
    ↓
NPU 输出（NC1HWC2, INT8/FP16）
    ↓ rknn_outputs_get()
    ├── NC1HWC2 → NCHW/NHWC
    ├── INT8 → FP32（(val - zp) * scale）
    └── 拷贝到用户缓冲
</code></pre>
<p>零拷贝路径跳过所有转换，用户直接操作 native layout。</p>
<hr />
<h2 id="七闭源库-vs-裸-ioctl-对照表"><a class="header" href="#七闭源库-vs-裸-ioctl-对照表">七、闭源库 vs 裸 ioctl 对照表</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">闭源库内部操作</th><th style="text-align: left">裸 ioctl demo 对应</th><th style="text-align: left">文件</th></tr></thead><tbody>
<tr><td style="text-align: left">模型解析</td><td style="text-align: left">无（用户手动定义参数）</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">CNA 描述符填充</td><td style="text-align: left"><code>gen_matmul_fp16()</code></td><td style="text-align: left"><code>npu_matmul.c</code></td></tr>
<tr><td style="text-align: left">DPU 描述符填充</td><td style="text-align: left"><code>gen_matmul_task()</code></td><td style="text-align: left"><code>npu_matmul.c</code></td></tr>
<tr><td style="text-align: left">NPUOP 编码</td><td style="text-align: left"><code>NPUOP()</code> 宏</td><td style="text-align: left"><code>npu_hw.h</code></td></tr>
<tr><td style="text-align: left">Task 构造</td><td style="text-align: left">手动填充 <code>tasks[0]</code></td><td style="text-align: left"><code>bench_mark.c</code></td></tr>
<tr><td style="text-align: left">Submit 构造</td><td style="text-align: left">手动填充 <code>submit</code></td><td style="text-align: left"><code>bench_mark.c</code></td></tr>
<tr><td style="text-align: left">权重转换</td><td style="text-align: left"><code>weight_fp16()</code> / <code>weight_int8()</code></td><td style="text-align: left"><code>npu_matmul.c</code></td></tr>
<tr><td style="text-align: left">特征排列</td><td style="text-align: left"><code>feature_data()</code></td><td style="text-align: left"><code>npu_matmul.c</code></td></tr>
<tr><td style="text-align: left">内存分配</td><td style="text-align: left"><code>mem_allocate()</code></td><td style="text-align: left"><code>npu_interface.c</code></td></tr>
<tr><td style="text-align: left">内存释放</td><td style="text-align: left"><code>mem_destroy()</code></td><td style="text-align: left"><code>npu_interface.c</code></td></tr>
<tr><td style="text-align: left">设备打开</td><td style="text-align: left"><code>npu_open()</code></td><td style="text-align: left"><code>npu_interface.c</code></td></tr>
<tr><td style="text-align: left">设备复位</td><td style="text-align: left"><code>npu_reset()</code></td><td style="text-align: left"><code>npu_interface.c</code></td></tr>
<tr><td style="text-align: left">Buffer 池化</td><td style="text-align: left"><code>NPUBuffer</code> 池</td><td style="text-align: left"><code>llama0.c</code></td></tr>
<tr><td style="text-align: left">权重缓存</td><td style="text-align: left"><code>NPUWeightCache</code></td><td style="text-align: left"><code>llama0.c</code></td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
